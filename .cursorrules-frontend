# ğŸ¨ Diretrizes de Desenvolvimento Frontend â€” Angular 20+ Zoneless / TypeScript 5.7+

> **Este documento define os princÃ­pios, padrÃµes e regras OBRIGATÃ“RIAS para desenvolvimento frontend moderno.**
> Consulte `.cursorrules` para visÃ£o geral e `.cursorrules-backend` para regras do backend.

---

## 1. STACK TECNOLÃ“GICA

| Tecnologia   | VersÃ£o      | ObservaÃ§Ã£o                           |
|--------------|-------------|--------------------------------------|
| Angular      | **20.x+**   | Zoneless estÃ¡vel, standalone padrÃ£o  |
| TypeScript   | **5.7+**    | Strict mode obrigatÃ³rio              |
| Node.js      | **22 LTS**  | Toolchain/bundler                    |
| RxJS         | **7.8+**    | Uso reduzido (preferir Signals)      |
| ESLint       | **9.x**     | Flat config obrigatÃ³rio              |
| Vitest       | **2.x**     | Alternativa moderna ao Jasmine       |

---

## 2. CONFIGURAÃ‡ÃƒO ZONELESS (OBRIGATÃ“RIO)

### 2.1 Bootstrap da AplicaÃ§Ã£o

```typescript
// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideExperimentalZonelessChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { AppComponent } from './app/app.component';
import { routes } from './app/app.routes';
import { authInterceptor } from './app/core/interceptors/auth.interceptor';
import { errorInterceptor } from './app/core/interceptors/error.interceptor';

bootstrapApplication(AppComponent, {
  providers: [
    // âœ… ZONELESS - Angular 20+
    provideExperimentalZonelessChangeDetection(),
    
    // âœ… Routing
    provideRouter(routes),
    
    // âœ… HTTP com interceptors funcionais
    provideHttpClient(
      withInterceptors([authInterceptor, errorInterceptor])
    ),
  ]
}).catch(err => console.error(err));
```

### 2.2 Remover Zone.js

```json
// angular.json - Remover zone.js dos polyfills
{
  "projects": {
    "app": {
      "architect": {
        "build": {
          "options": {
            "polyfills": []  // âœ… Sem zone.js
          }
        }
      }
    }
  }
}
```

---

## 3. SINTAXE MODERNA OBRIGATÃ“RIA

### 3.1 InjeÃ§Ã£o de DependÃªncia

```typescript
// âœ… CORRETO - inject()
export class ProdutoService {
  private readonly http = inject(HttpClient);
  private readonly config = inject(APP_CONFIG);
}

// âŒ ERRADO - Constructor injection
export class ProdutoService {
  constructor(private http: HttpClient) {} // PROIBIDO!
}
```

### 3.2 Signals e Reactive State

```typescript
// âœ… CORRETO - Signals para estado
export class ProdutoListaComponent {
  private readonly produtoService = inject(ProdutoService);
  
  // State
  readonly produtos = signal<Produto[]>([]);
  readonly carregando = signal(false);
  readonly erro = signal<string | null>(null);
  readonly filtro = signal('');
  
  // Computed
  readonly produtosFiltrados = computed(() => {
    const termo = this.filtro().toLowerCase();
    return this.produtos().filter(p => 
      p.nome.toLowerCase().includes(termo)
    );
  });
  
  readonly totalProdutos = computed(() => this.produtosFiltrados().length);
  
  // Effects
  constructor() {
    effect(() => {
      console.log('Produtos atualizados:', this.produtos().length);
    });
  }
}

// âŒ ERRADO - BehaviorSubject para estado local
export class ProdutoListaComponent {
  produtos$ = new BehaviorSubject<Produto[]>([]); // PROIBIDO!
}
```

### 3.3 Input/Output com Signals

```typescript
// âœ… CORRETO - input() e output()
@Component({
  selector: 'app-produto-card',
  standalone: true,
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="card" (click)="onSelecionar()">
      <h3>{{ produto().nome }}</h3>
      <p>{{ produto().preco | currency }}</p>
      @if (destaque()) {
        <span class="badge">Destaque</span>
      }
    </div>
  `
})
export class ProdutoCardComponent {
  // Inputs
  readonly produto = input.required<Produto>();
  readonly destaque = input(false);
  
  // Outputs
  readonly selecionar = output<Produto>();
  
  onSelecionar(): void {
    this.selecionar.emit(this.produto());
  }
}

// âŒ ERRADO - Decorators antigos
@Component({...})
export class ProdutoCardComponent {
  @Input() produto!: Produto; // PROIBIDO!
  @Output() selecionar = new EventEmitter<Produto>(); // PROIBIDO!
}
```

### 3.4 Control Flow Moderno

```html
<!-- âœ… CORRETO - @if, @for, @switch, @defer -->
@if (carregando()) {
  <app-loading />
} @else if (erro()) {
  <app-error [message]="erro()" />
} @else {
  @for (produto of produtosFiltrados(); track produto.id) {
    <app-produto-card 
      [produto]="produto"
      [destaque]="produto.destaque"
      (selecionar)="onProdutoSelecionado($event)"
    />
  } @empty {
    <p>Nenhum produto encontrado</p>
  }
}

@switch (status()) {
  @case ('pendente') {
    <span class="badge-warning">Pendente</span>
  }
  @case ('aprovado') {
    <span class="badge-success">Aprovado</span>
  }
  @default {
    <span class="badge-secondary">Desconhecido</span>
  }
}

<!-- Lazy loading com @defer -->
@defer (on viewport) {
  <app-grafico-vendas [dados]="vendas()" />
} @placeholder {
  <div class="skeleton-chart"></div>
} @loading (minimum 300ms) {
  <app-spinner />
}

<!-- âŒ ERRADO - Diretivas antigas -->
<div *ngIf="carregando">...</div>  <!-- PROIBIDO! -->
<div *ngFor="let p of produtos">...</div>  <!-- PROIBIDO! -->
```

---

## 4. ARQUITETURA DE COMPONENTES

### 4.1 Estrutura de Pastas

```
src/app/
â”œâ”€â”€ core/                       # Singleton services, guards, interceptors
â”‚   â”œâ”€â”€ guards/
â”‚   â”‚   â””â”€â”€ auth.guard.ts
â”‚   â”œâ”€â”€ interceptors/
â”‚   â”‚   â”œâ”€â”€ auth.interceptor.ts
â”‚   â”‚   â””â”€â”€ error.interceptor.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ auth.service.ts
â”‚   â””â”€â”€ tokens/
â”‚       â””â”€â”€ app-config.token.ts
â”‚
â”œâ”€â”€ shared/                     # MÃ³dulo compartilhado
â”‚   â”œâ”€â”€ components/             # Dumb components
â”‚   â”‚   â”œâ”€â”€ button/
â”‚   â”‚   â”œâ”€â”€ modal/
â”‚   â”‚   â”œâ”€â”€ data-table/
â”‚   â”‚   â””â”€â”€ form-field/
â”‚   â”œâ”€â”€ directives/
â”‚   â”‚   â””â”€â”€ tooltip.directive.ts
â”‚   â”œâ”€â”€ pipes/
â”‚   â”‚   â”œâ”€â”€ cpf-cnpj.pipe.ts
â”‚   â”‚   â””â”€â”€ currency-br.pipe.ts
â”‚   â”œâ”€â”€ models/                 # Interfaces compartilhadas
â”‚   â”‚   â””â”€â”€ pagination.model.ts
â”‚   â””â”€â”€ utils/                  # UtilitÃ¡rios puros
â”‚       â””â”€â”€ validators.ts
â”‚
â”œâ”€â”€ features/                   # Feature modules (por domÃ­nio)
â”‚   â”œâ”€â”€ produtos/
â”‚   â”‚   â”œâ”€â”€ pages/              # Smart components
â”‚   â”‚   â”‚   â”œâ”€â”€ produto-lista/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ produto-lista.component.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ produto-lista.component.html
â”‚   â”‚   â”‚   â””â”€â”€ produto-detalhe/
â”‚   â”‚   â”œâ”€â”€ components/         # Componentes da feature
â”‚   â”‚   â”‚   â””â”€â”€ produto-card/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ produto.service.ts
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ produto.model.ts
â”‚   â”‚   â”‚   â””â”€â”€ filtro-produto.model.ts
â”‚   â”‚   â”œâ”€â”€ composables/        # LÃ³gica reutilizÃ¡vel
â”‚   â”‚   â”‚   â””â”€â”€ use-produto-filtro.ts
â”‚   â”‚   â””â”€â”€ produtos.routes.ts
â”‚   â”‚
â”‚   â””â”€â”€ pedidos/
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ app.component.ts
â”œâ”€â”€ app.config.ts
â””â”€â”€ app.routes.ts
```

### 4.2 Smart vs Dumb Components

| Aspecto | Smart (Pages) | Dumb (Shared/Components) |
|---------|---------------|--------------------------|
| LocalizaÃ§Ã£o | `features/{feature}/pages/` | `shared/components/` |
| Injeta services | âœ… Sim | âŒ NÃ£o |
| Conhece negÃ³cio | âœ… Sim | âŒ NÃ£o |
| Estado | Gerencia estado | Recebe via `input()` |
| ComunicaÃ§Ã£o | Chama services | Emite via `output()` |
| ReutilizaÃ§Ã£o | EspecÃ­fico | Alto reuso |

```typescript
// âœ… Smart Component (Page)
@Component({
  selector: 'app-pedido-lista',
  standalone: true,
  imports: [DataTableComponent, PedidoFiltroComponent],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <app-pedido-filtro 
      (filtrar)="onFiltrar($event)" 
    />
    <app-data-table 
      [dados]="pedidos()"
      [colunas]="colunas"
      [carregando]="carregando()"
      (paginar)="onPaginar($event)"
    />
  `
})
export class PedidoListaComponent {
  private readonly pedidoService = inject(PedidoService);
  
  readonly pedidos = signal<Pedido[]>([]);
  readonly carregando = signal(false);
  readonly colunas = COLUNAS_PEDIDO;
  
  onFiltrar(filtro: FiltroPedido): void {
    this.carregando.set(true);
    this.pedidoService.listar(filtro).subscribe({
      next: (dados) => {
        this.pedidos.set(dados);
        this.carregando.set(false);
      },
      error: () => this.carregando.set(false)
    });
  }
}

// âœ… Dumb Component (Shared)
@Component({
  selector: 'app-data-table',
  standalone: true,
  imports: [CommonModule],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    @if (carregando()) {
      <app-loading />
    } @else {
      <table>
        <thead>...</thead>
        <tbody>
          @for (item of dados(); track trackFn) {
            <tr (click)="onSelecionar(item)">...</tr>
          }
        </tbody>
      </table>
    }
  `
})
export class DataTableComponent<T> {
  readonly dados = input.required<T[]>();
  readonly colunas = input.required<Coluna[]>();
  readonly carregando = input(false);
  readonly trackFn = input<TrackByFunction<T>>((_, item) => item);
  
  readonly selecionar = output<T>();
  readonly paginar = output<EventoPaginacao>();
  
  onSelecionar(item: T): void {
    this.selecionar.emit(item);
  }
}
```

---

## 5. COMPOSABLES (REUTILIZAÃ‡ÃƒO DE LÃ“GICA)

```typescript
// composables/use-paginacao.ts
export function usePaginacao<T>(
  fetchFn: (page: number, pageSize: number) => Observable<ResultadoPaginado<T>>,
  options?: { pageSize?: number }
) {
  const dados = signal<T[]>([]);
  const paginaAtual = signal(1);
  const totalItens = signal(0);
  const totalPaginas = signal(0);
  const carregando = signal(false);
  const pageSize = options?.pageSize ?? 10;

  const carregar = (page: number = 1) => {
    carregando.set(true);
    fetchFn(page, pageSize).subscribe({
      next: (resultado) => {
        dados.set(resultado.dados);
        totalItens.set(resultado.total);
        totalPaginas.set(Math.ceil(resultado.total / pageSize));
        paginaAtual.set(page);
        carregando.set(false);
      },
      error: () => carregando.set(false)
    });
  };

  const proximaPagina = () => {
    if (paginaAtual() < totalPaginas()) {
      carregar(paginaAtual() + 1);
    }
  };

  const paginaAnterior = () => {
    if (paginaAtual() > 1) {
      carregar(paginaAtual() - 1);
    }
  };

  return {
    dados: dados.asReadonly(),
    paginaAtual: paginaAtual.asReadonly(),
    totalItens: totalItens.asReadonly(),
    totalPaginas: totalPaginas.asReadonly(),
    carregando: carregando.asReadonly(),
    carregar,
    proximaPagina,
    paginaAnterior
  };
}

// Uso no componente
@Component({...})
export class ProdutoListaComponent {
  private readonly produtoService = inject(ProdutoService);
  
  readonly paginacao = usePaginacao(
    (page, size) => this.produtoService.listar({ page, size })
  );
  
  ngOnInit(): void {
    this.paginacao.carregar();
  }
}
```

```typescript
// composables/use-form.ts
export function useForm<T extends Record<string, any>>(initialValues: T) {
  const valores = signal<T>(initialValues);
  const erros = signal<Partial<Record<keyof T, string>>>({});
  const tocado = signal<Partial<Record<keyof T, boolean>>>({});
  const submetendo = signal(false);

  const setValor = <K extends keyof T>(campo: K, valor: T[K]) => {
    valores.update(v => ({ ...v, [campo]: valor }));
    tocado.update(t => ({ ...t, [campo]: true }));
  };

  const setErro = <K extends keyof T>(campo: K, erro: string | null) => {
    erros.update(e => {
      const novos = { ...e };
      if (erro) {
        novos[campo] = erro;
      } else {
        delete novos[campo];
      }
      return novos;
    });
  };

  const reset = () => {
    valores.set(initialValues);
    erros.set({});
    tocado.set({});
    submetendo.set(false);
  };

  const isValido = computed(() => Object.keys(erros()).length === 0);

  return {
    valores: valores.asReadonly(),
    erros: erros.asReadonly(),
    tocado: tocado.asReadonly(),
    submetendo,
    isValido,
    setValor,
    setErro,
    reset
  };
}
```

---

## 6. SERVICES E HTTP

### 6.1 Service Base

```typescript
// core/services/base-http.service.ts
export abstract class BaseHttpService {
  protected readonly http = inject(HttpClient);
  protected readonly config = inject(APP_CONFIG);
  
  protected get baseUrl(): string {
    return this.config.apiUrl;
  }
  
  protected handleError<T>(operation: string) {
    return (error: HttpErrorResponse): Observable<never> => {
      console.error(`${operation} falhou:`, error);
      
      const mensagem = error.error?.message ?? 'Erro desconhecido';
      return throwError(() => new Error(mensagem));
    };
  }
}
```

### 6.2 Feature Service

```typescript
// features/produtos/services/produto.service.ts
@Injectable({ providedIn: 'root' })
export class ProdutoService extends BaseHttpService {
  
  private readonly url = `${this.baseUrl}/produtos`;
  
  listar(filtro?: FiltroProduto): Observable<ResultadoPaginado<Produto>> {
    const params = this.buildParams(filtro);
    return this.http.get<ResultadoPaginado<Produto>>(this.url, { params }).pipe(
      catchError(this.handleError('listar produtos'))
    );
  }
  
  buscarPorId(id: string): Observable<Produto> {
    return this.http.get<Produto>(`${this.url}/${id}`).pipe(
      catchError(this.handleError('buscar produto'))
    );
  }
  
  criar(produto: CriarProdutoRequest): Observable<Produto> {
    return this.http.post<Produto>(this.url, produto).pipe(
      catchError(this.handleError('criar produto'))
    );
  }
  
  atualizar(id: string, produto: AtualizarProdutoRequest): Observable<Produto> {
    return this.http.put<Produto>(`${this.url}/${id}`, produto).pipe(
      catchError(this.handleError('atualizar produto'))
    );
  }
  
  excluir(id: string): Observable<void> {
    return this.http.delete<void>(`${this.url}/${id}`).pipe(
      catchError(this.handleError('excluir produto'))
    );
  }
  
  private buildParams(filtro?: FiltroProduto): HttpParams {
    let params = new HttpParams();
    if (filtro) {
      Object.entries(filtro).forEach(([key, value]) => {
        if (value != null) {
          params = params.set(key, String(value));
        }
      });
    }
    return params;
  }
}
```

### 6.3 Interceptors Funcionais

```typescript
// core/interceptors/auth.interceptor.ts
export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const token = authService.token();
  
  if (token) {
    req = req.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`
      }
    });
  }
  
  return next(req);
};

// core/interceptors/error.interceptor.ts
export const errorInterceptor: HttpInterceptorFn = (req, next) => {
  const notificationService = inject(NotificationService);
  
  return next(req).pipe(
    catchError((error: HttpErrorResponse) => {
      if (error.status === 401) {
        notificationService.erro('SessÃ£o expirada. FaÃ§a login novamente.');
      } else if (error.status >= 500) {
        notificationService.erro('Erro interno do servidor.');
      }
      return throwError(() => error);
    })
  );
};
```

---

## 7. MODELS E TIPOS

```typescript
// shared/models/pagination.model.ts
export interface ResultadoPaginado<T> {
  dados: T[];
  total: number;
  pagina: number;
  tamanhoPagina: number;
}

export interface EventoPaginacao {
  pagina: number;
  tamanhoPagina: number;
}

// features/produtos/models/produto.model.ts
export interface Produto {
  id: string;
  nome: string;
  descricao: string;
  preco: number;
  estoque: number;
  categoria: Categoria;
  ativo: boolean;
  dataCriacao: string;
}

export interface CriarProdutoRequest {
  nome: string;
  descricao: string;
  preco: number;
  estoque: number;
  categoriaId: string;
}

export interface AtualizarProdutoRequest extends Partial<CriarProdutoRequest> {}

export interface FiltroProduto {
  nome?: string;
  categoriaId?: string;
  ativo?: boolean;
  page?: number;
  size?: number;
}

// âœ… Type guard para validaÃ§Ã£o em runtime
export function isProduto(obj: unknown): obj is Produto {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'nome' in obj &&
    'preco' in obj
  );
}
```

---

## 8. ROTAS E LAZY LOADING

```typescript
// app.routes.ts
export const routes: Routes = [
  {
    path: '',
    redirectTo: 'dashboard',
    pathMatch: 'full'
  },
  {
    path: 'dashboard',
    loadComponent: () => import('./features/dashboard/pages/dashboard.component')
      .then(m => m.DashboardComponent)
  },
  {
    path: 'produtos',
    loadChildren: () => import('./features/produtos/produtos.routes')
      .then(m => m.PRODUTOS_ROUTES),
    canActivate: [authGuard]
  },
  {
    path: 'pedidos',
    loadChildren: () => import('./features/pedidos/pedidos.routes')
      .then(m => m.PEDIDOS_ROUTES),
    canActivate: [authGuard]
  },
  {
    path: '**',
    loadComponent: () => import('./shared/components/not-found/not-found.component')
      .then(m => m.NotFoundComponent)
  }
];

// features/produtos/produtos.routes.ts
export const PRODUTOS_ROUTES: Routes = [
  {
    path: '',
    loadComponent: () => import('./pages/produto-lista/produto-lista.component')
      .then(m => m.ProdutoListaComponent)
  },
  {
    path: 'novo',
    loadComponent: () => import('./pages/produto-form/produto-form.component')
      .then(m => m.ProdutoFormComponent)
  },
  {
    path: ':id',
    loadComponent: () => import('./pages/produto-detalhe/produto-detalhe.component')
      .then(m => m.ProdutoDetalheComponent)
  },
  {
    path: ':id/editar',
    loadComponent: () => import('./pages/produto-form/produto-form.component')
      .then(m => m.ProdutoFormComponent)
  }
];
```

---

## 9. SSR E HIDRATAÃ‡ÃƒO

```typescript
// VerificaÃ§Ã£o de plataforma
import { isPlatformBrowser, isPlatformServer } from '@angular/common';
import { PLATFORM_ID } from '@angular/core';

@Component({...})
export class ProdutoListaComponent {
  private readonly platformId = inject(PLATFORM_ID);
  private readonly produtoService = inject(ProdutoService);
  
  readonly produtos = signal<Produto[]>([]);
  
  ngOnInit(): void {
    // âœ… SÃ³ executa no browser
    if (isPlatformBrowser(this.platformId)) {
      this.carregarProdutos();
    }
  }
  
  private carregarProdutos(): void {
    this.produtoService.listar().subscribe(resultado => {
      this.produtos.set(resultado.dados);
    });
  }
}

// Timers e subscriptions
@Component({...})
export class DashboardComponent implements OnInit, OnDestroy {
  private readonly ngZone = inject(NgZone);
  private readonly destroyRef = inject(DestroyRef);
  
  ngOnInit(): void {
    // âœ… Polling fora do Angular
    this.ngZone.runOutsideAngular(() => {
      const interval = setInterval(() => {
        this.ngZone.run(() => this.atualizarDados());
      }, 30000);
      
      this.destroyRef.onDestroy(() => clearInterval(interval));
    });
  }
}
```

---

## 10. TESTES

### Estrutura de Testes

```typescript
// produto.service.spec.ts
describe('ProdutoService', () => {
  let service: ProdutoService;
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        provideHttpClient(),
        provideHttpClientTesting(),
        { provide: APP_CONFIG, useValue: { apiUrl: '/api' } }
      ]
    });
    
    service = TestBed.inject(ProdutoService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify();
  });

  it('deve listar produtos', () => {
    const mockProdutos: ResultadoPaginado<Produto> = {
      dados: [{ id: '1', nome: 'Produto 1', preco: 100 } as Produto],
      total: 1,
      pagina: 1,
      tamanhoPagina: 10
    };

    service.listar().subscribe(resultado => {
      expect(resultado.dados.length).toBe(1);
      expect(resultado.dados[0].nome).toBe('Produto 1');
    });

    const req = httpMock.expectOne('/api/produtos');
    expect(req.request.method).toBe('GET');
    req.flush(mockProdutos);
  });
});
```

```typescript
// produto-card.component.spec.ts
describe('ProdutoCardComponent', () => {
  let fixture: ComponentFixture<ProdutoCardComponent>;
  let component: ProdutoCardComponent;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ProdutoCardComponent]
    }).compileComponents();

    fixture = TestBed.createComponent(ProdutoCardComponent);
    component = fixture.componentInstance;
  });

  it('deve emitir evento ao selecionar', () => {
    const produto: Produto = { id: '1', nome: 'Teste', preco: 100 } as Produto;
    fixture.componentRef.setInput('produto', produto);
    
    const spy = jest.spyOn(component.selecionar, 'emit');
    
    component.onSelecionar();
    
    expect(spy).toHaveBeenCalledWith(produto);
  });
});
```

---

## 11. CHECKLIST DE QUALIDADE

### Antes de Commitar

#### Arquitetura

- [ ] Standalone components apenas
- [ ] Smart/Dumb components separados corretamente
- [ ] Services na camada correta (core vs feature)
- [ ] Models bem tipados (sem `any`)
- [ ] Composables para lÃ³gica reutilizÃ¡vel

#### Sintaxe Moderna

- [ ] `inject()` para DI (nÃ£o constructor)
- [ ] `signal()`, `computed()`, `effect()` para estado
- [ ] `input()`, `output()` (nÃ£o decorators)
- [ ] `@if`, `@for`, `@switch`, `@defer` (nÃ£o diretivas)
- [ ] `ChangeDetectionStrategy.OnPush` em todos componentes

#### Zoneless

- [ ] `provideExperimentalZonelessChangeDetection()` configurado
- [ ] `zone.js` removido dos polyfills
- [ ] Signals para reatividade
- [ ] `markForCheck()` se necessÃ¡rio manualmente

#### Qualidade

- [ ] Arquivos com menos de 300 linhas
- [ ] FunÃ§Ãµes com menos de 20 linhas
- [ ] Sem cÃ³digo duplicado (DRY)
- [ ] Nomes descritivos
- [ ] Testes cobrindo lÃ³gica

---

## 12. ğŸ” SEGURANÃ‡A FRONTEND (OWASP / Angular Security)

### 12.1 Content Security Policy (CSP)

```typescript
// âœ… main.ts - Configurar CSP Nonce (Angular 20+)
import { bootstrapApplication, CSP_NONCE } from '@angular/platform-browser';
import { provideExperimentalZonelessChangeDetection } from '@angular/core';

bootstrapApplication(AppComponent, {
  providers: [
    provideExperimentalZonelessChangeDetection(),
    
    // âœ… CSP Nonce para scripts inline
    {
      provide: CSP_NONCE,
      useValue: (globalThis as any).cspNonce // Fornecido pelo servidor
    }
  ]
});
```

```json
// âœ… angular.json - Habilitar CSP automÃ¡tico
{
  "projects": {
    "app": {
      "architect": {
        "build": {
          "options": {
            "autoCsp": true  // Angular 20+ gera nonces automaticamente
          }
        }
      }
    }
  }
}
```

```
# âœ… Headers CSP (configurar no servidor/proxy)
Content-Security-Policy: 
  default-src 'self'; 
  script-src 'self' 'nonce-{RANDOM_NONCE}'; 
  style-src 'self' 'nonce-{RANDOM_NONCE}'; 
  img-src 'self' data: https:; 
  font-src 'self'; 
  connect-src 'self' https://api.meudominio.com.br; 
  frame-ancestors 'none'; 
  base-uri 'self'; 
  form-action 'self';
```

### 12.2 XSS Prevention (Cross-Site Scripting)

```typescript
// âœ… Angular sanitiza automaticamente - NÃƒO desabilite sem necessidade
@Component({
  template: `
    <!-- âœ… SEGURO - Angular sanitiza automaticamente -->
    <div>{{ userInput }}</div>
    <div [textContent]="userInput"></div>
    
    <!-- âš ï¸ CUIDADO - innerHTML Ã© sanitizado, mas evite quando possÃ­vel -->
    <div [innerHTML]="htmlContent"></div>
    
    <!-- âŒ NUNCA - Bypass de seguranÃ§a sem validaÃ§Ã£o -->
    <!-- <div [innerHTML]="trustedHtml"></div> -->
  `
})
export class ExemploComponent {
  private readonly sanitizer = inject(DomSanitizer);
  
  userInput = signal('<script>alert("xss")</script>');
  
  // âš ï¸ CUIDADO - SÃ³ usar quando absolutamente necessÃ¡rio
  // e APENAS com conteÃºdo que vocÃª controla
  get trustedHtml() {
    // âŒ NUNCA fazer isso com input do usuÃ¡rio!
    return this.sanitizer.bypassSecurityTrustHtml(this.htmlContent);
  }
}

// âœ… Se precisar de HTML dinÃ¢mico, use DomSanitizer.sanitize()
@Injectable({ providedIn: 'root' })
export class SafeHtmlService {
  private readonly sanitizer = inject(DomSanitizer);
  
  sanitizeHtml(html: string): SafeHtml {
    // âœ… Sanitiza mas mantÃ©m tags HTML seguras
    return this.sanitizer.sanitize(SecurityContext.HTML, html) || '';
  }
}
```

### 12.3 CSRF/XSRF Protection

```typescript
// âœ… main.ts - Configurar XSRF
import { provideHttpClient, withXsrfConfiguration } from '@angular/common/http';

bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient(
      // âœ… XSRF automÃ¡tico - Angular lÃª cookie e envia header
      withXsrfConfiguration({
        cookieName: 'XSRF-TOKEN',      // Nome do cookie (padrÃ£o)
        headerName: 'X-XSRF-TOKEN'      // Nome do header (padrÃ£o)
      })
    )
  ]
});

// âš ï¸ NOTA: O backend deve:
// 1. Enviar cookie XSRF-TOKEN em respostas
// 2. Validar header X-XSRF-TOKEN em requisiÃ§Ãµes POST/PUT/DELETE
```

### 12.4 Authentication & Token Storage

```typescript
// âœ… ServiÃ§o de autenticaÃ§Ã£o seguro
@Injectable({ providedIn: 'root' })
export class AuthService {
  private readonly http = inject(HttpClient);
  private readonly router = inject(Router);
  
  // âœ… Estado de autenticaÃ§Ã£o
  private readonly _isAuthenticated = signal(false);
  private readonly _currentUser = signal<User | null>(null);
  
  readonly isAuthenticated = this._isAuthenticated.asReadonly();
  readonly currentUser = this._currentUser.asReadonly();
  
  constructor() {
    // âœ… Verificar token ao inicializar (se usar localStorage)
    this.checkStoredToken();
    
    // âœ… Auto-logout em inatividade (15 minutos)
    this.setupInactivityLogout(15 * 60 * 1000);
  }
  
  login(credentials: LoginRequest): Observable<LoginResponse> {
    return this.http.post<LoginResponse>('/api/auth/login', credentials).pipe(
      tap(response => {
        // âš ï¸ OPÃ‡ÃƒO 1: Memory only (mais seguro, perde no refresh)
        this.storeTokenInMemory(response.accessToken);
        
        // âš ï¸ OPÃ‡ÃƒO 2: sessionStorage (persiste na aba, vulnerÃ¡vel a XSS)
        // sessionStorage.setItem('accessToken', response.accessToken);
        
        // âŒ EVITAR: localStorage (persiste sempre, vulnerÃ¡vel a XSS)
        // localStorage.setItem('accessToken', response.accessToken);
        
        // âœ… IDEAL: HttpOnly Cookie (configurado pelo backend)
        // Backend retorna token em cookie HttpOnly, Secure, SameSite=Strict
        
        this._isAuthenticated.set(true);
        this._currentUser.set(response.user);
      })
    );
  }
  
  logout(): void {
    // âœ… Limpar estado
    this._isAuthenticated.set(false);
    this._currentUser.set(null);
    this.accessToken = null;
    
    // âœ… Limpar storage
    sessionStorage.removeItem('accessToken');
    
    // âœ… Notificar backend para invalidar token
    this.http.post('/api/auth/logout', {}).subscribe();
    
    this.router.navigate(['/login']);
  }
  
  // âœ… Token em memÃ³ria (mais seguro)
  private accessToken: string | null = null;
  
  private storeTokenInMemory(token: string): void {
    this.accessToken = token;
  }
  
  getAccessToken(): string | null {
    return this.accessToken;
  }
  
  // âœ… Auto-logout por inatividade
  private setupInactivityLogout(timeout: number): void {
    let inactivityTimer: number;
    
    const resetTimer = () => {
      clearTimeout(inactivityTimer);
      inactivityTimer = window.setTimeout(() => {
        if (this._isAuthenticated()) {
          this.logout();
          alert('SessÃ£o expirada por inatividade');
        }
      }, timeout);
    };
    
    ['click', 'keydown', 'scroll', 'mousemove'].forEach(event => {
      document.addEventListener(event, resetTimer);
    });
    
    resetTimer();
  }
}
```

### 12.5 Auth Interceptor Seguro

```typescript
// âœ… core/interceptors/auth.interceptor.ts
export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  // âœ… URLs pÃºblicas - nÃ£o adicionar token
  const publicUrls = ['/api/auth/login', '/api/auth/register', '/api/public'];
  if (publicUrls.some(url => req.url.includes(url))) {
    return next(req);
  }
  
  const token = authService.getAccessToken();
  
  if (token) {
    // âœ… Clonar request e adicionar header
    const authReq = req.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`
      }
    });
    
    return next(authReq).pipe(
      catchError((error: HttpErrorResponse) => {
        if (error.status === 401) {
          // âœ… Token expirado - fazer logout
          authService.logout();
          router.navigate(['/login']);
        }
        return throwError(() => error);
      })
    );
  }
  
  return next(req);
};
```

### 12.6 Route Guards

```typescript
// âœ… core/guards/auth.guard.ts - Funcional (Angular 20+)
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  if (authService.isAuthenticated()) {
    return true;
  }
  
  // âœ… Redirecionar para login com returnUrl
  return router.createUrlTree(['/login'], {
    queryParams: { returnUrl: state.url }
  });
};

// âœ… core/guards/role.guard.ts - VerificaÃ§Ã£o de roles
export const roleGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  const requiredRoles = route.data['roles'] as string[];
  const user = authService.currentUser();
  
  if (!user) {
    return router.createUrlTree(['/login']);
  }
  
  const hasRole = requiredRoles.some(role => user.roles.includes(role));
  
  if (!hasRole) {
    // âœ… UsuÃ¡rio nÃ£o tem permissÃ£o
    return router.createUrlTree(['/unauthorized']);
  }
  
  return true;
};

// âœ… Uso nas rotas
export const routes: Routes = [
  {
    path: 'admin',
    loadComponent: () => import('./admin/admin.component'),
    canActivate: [authGuard, roleGuard],
    data: { roles: ['ADMIN'] }
  },
  {
    path: 'dashboard',
    loadComponent: () => import('./dashboard/dashboard.component'),
    canActivate: [authGuard]
  }
];
```

### 12.7 Secure HTTP Service Base

```typescript
// âœ… core/services/base-http.service.ts
@Injectable({ providedIn: 'root' })
export abstract class BaseHttpService {
  protected readonly http = inject(HttpClient);
  protected readonly config = inject(APP_CONFIG);
  
  protected get baseUrl(): string {
    return this.config.apiUrl;
  }
  
  // âœ… Handler de erros padronizado - nÃ£o expÃµe detalhes sensÃ­veis
  protected handleError(operation: string) {
    return (error: HttpErrorResponse): Observable<never> => {
      // âœ… Log interno (nÃ£o enviar para console em produÃ§Ã£o)
      if (!environment.production) {
        console.error(`${operation} failed:`, error);
      }
      
      // âœ… Mensagem genÃ©rica para o usuÃ¡rio
      let userMessage = 'Ocorreu um erro. Tente novamente.';
      
      if (error.status === 0) {
        userMessage = 'Erro de conexÃ£o. Verifique sua internet.';
      } else if (error.status === 403) {
        userMessage = 'VocÃª nÃ£o tem permissÃ£o para esta aÃ§Ã£o.';
      } else if (error.status === 404) {
        userMessage = 'Recurso nÃ£o encontrado.';
      } else if (error.status >= 500) {
        userMessage = 'Erro no servidor. Tente novamente mais tarde.';
      }
      
      // âŒ NUNCA expor stack trace ou detalhes tÃ©cnicos
      return throwError(() => new Error(userMessage));
    };
  }
}
```

### 12.8 Input Sanitization

```typescript
// âœ… shared/utils/sanitize.util.ts
export class SanitizeUtil {
  
  // âœ… Sanitizar input de texto
  static sanitizeText(input: string): string {
    if (!input) return '';
    
    return input
      .trim()
      .replace(/[<>]/g, '') // Remove < e >
      .substring(0, 1000);  // Limita tamanho
  }
  
  // âœ… Sanitizar para uso em URLs
  static sanitizeUrlParam(input: string): string {
    if (!input) return '';
    
    return encodeURIComponent(
      input.trim().replace(/[^\w\s-]/g, '')
    );
  }
  
  // âœ… Validar email
  static isValidEmail(email: string): boolean {
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return emailRegex.test(email);
  }
  
  // âœ… Validar CPF (apenas formato, nÃ£o validaÃ§Ã£o matemÃ¡tica)
  static isValidCpfFormat(cpf: string): boolean {
    const cpfRegex = /^\d{3}\.\d{3}\.\d{3}-\d{2}$/;
    return cpfRegex.test(cpf);
  }
}

// âœ… Uso em formulÃ¡rios
@Component({...})
export class FormComponent {
  readonly nome = signal('');
  readonly email = signal('');
  
  onNomeChange(event: Event): void {
    const input = (event.target as HTMLInputElement).value;
    this.nome.set(SanitizeUtil.sanitizeText(input));
  }
  
  onSubmit(): void {
    if (!SanitizeUtil.isValidEmail(this.email())) {
      // Mostrar erro
      return;
    }
    // Continuar...
  }
}
```

### 12.9 Secure Environment Configuration

```typescript
// âœ… environments/environment.ts (desenvolvimento)
export const environment = {
  production: false,
  apiUrl: 'http://localhost:8080/api',
  // âŒ NUNCA incluir secrets aqui
};

// âœ… environments/environment.prod.ts (produÃ§Ã£o)
export const environment = {
  production: true,
  apiUrl: 'https://api.meudominio.com.br/api',
  // âœ… Em produÃ§Ã£o, URLs vÃªm do servidor ou build time
};
```

```json
// âœ… angular.json - Desabilitar source maps em produÃ§Ã£o
{
  "projects": {
    "app": {
      "architect": {
        "build": {
          "configurations": {
            "production": {
              "sourceMap": false,        // âœ… NÃ£o expor cÃ³digo fonte
              "optimization": true,
              "namedChunks": false,
              "budgets": [...]
            }
          }
        }
      }
    }
  }
}
```

### 12.10 Checklist de SeguranÃ§a Frontend

#### Antes do Deploy

- [ ] **HTTPS** obrigatÃ³rio em produÃ§Ã£o
- [ ] **CSP** (Content Security Policy) configurado
- [ ] **Source maps** desabilitados em produÃ§Ã£o
- [ ] **Console.log** removidos ou condicionais
- [ ] **Tokens** nÃ£o armazenados em localStorage (preferir memory/HttpOnly cookie)
- [ ] **SanitizaÃ§Ã£o** de inputs do usuÃ¡rio
- [ ] **ValidaÃ§Ã£o** client-side + server-side
- [ ] **XSRF** configurado para formulÃ¡rios
- [ ] **Guards** protegendo rotas sensÃ­veis
- [ ] **Error handling** nÃ£o expÃµe detalhes tÃ©cnicos
- [ ] **Dependencies** verificadas (npm audit)
- [ ] **Trusted Types** habilitado (quando possÃ­vel)
- [ ] **AOT compilation** habilitado (padrÃ£o Angular)
- [ ] **Strict mode** TypeScript habilitado
- [ ] **@angular-eslint/security** regras habilitadas

#### VerificaÃ§Ã£o de DependÃªncias

```bash
# âœ… Verificar vulnerabilidades
npm audit

# âœ… Corrigir automaticamente quando possÃ­vel
npm audit fix

# âœ… Usar renovate/dependabot para updates automÃ¡ticos
```

---

## 13. ANTI-PATTERNS (PROIBIDOS)

### CÃ³digo

1. âŒ Constructor injection (`constructor(private http: HttpClient)`)
2. âŒ Decorators `@Input()` e `@Output()`
3. âŒ Diretivas `*ngIf`, `*ngFor`, `*ngSwitch`
4. âŒ NgModules (exceto bibliotecas externas)
5. âŒ BehaviorSubject para estado local
6. âŒ `any` sem tipagem adequada
7. âŒ Subscribe sem cleanup
8. âŒ MutaÃ§Ã£o direta de signals (`signal().push()`)
9. âŒ LÃ³gica de negÃ³cio em templates
10. âŒ Magic strings/numbers

### Arquitetura

11. âŒ Service injection em Dumb Components
12. âŒ Estado global espalhado
13. âŒ HTTP direto em components (sem service)
14. âŒ Componentes gigantes (>300 linhas)
15. âŒ Zone.js em modo zoneless

### SeguranÃ§a

16. âŒ Armazenar tokens em localStorage (use memory ou HttpOnly cookie)
17. âŒ Bypass de DomSanitizer sem validaÃ§Ã£o
18. âŒ Console.log em produÃ§Ã£o com dados sensÃ­veis
19. âŒ Source maps habilitados em produÃ§Ã£o
20. âŒ Expor stack traces em mensagens de erro

---

## 14. REFERÃŠNCIA RÃPIDA

### Novo Componente

```typescript
@Component({
  selector: 'app-exemplo',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './exemplo.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ExemploComponent {
  // 1. InjeÃ§Ãµes
  private readonly service = inject(ExemploService);
  
  // 2. Inputs/Outputs
  readonly item = input.required<Item>();
  readonly opcional = input('default');
  readonly onSalvar = output<Item>();
  
  // 3. State
  readonly carregando = signal(false);
  readonly dados = signal<Dados[]>([]);
  
  // 4. Computeds
  readonly itemValido = computed(() => this.validar(this.item()));
  readonly totalDados = computed(() => this.dados().length);
  
  // 5. Effects
  constructor() {
    effect(() => {
      console.log('Item mudou:', this.item());
    });
  }
  
  // 6. Methods
  salvar(): void {
    this.onSalvar.emit(this.item());
  }
}
```

### Novo Service

```typescript
@Injectable({ providedIn: 'root' })
export class ExemploService extends BaseHttpService {
  
  private readonly url = `${this.baseUrl}/exemplos`;
  
  listar(): Observable<Exemplo[]> {
    return this.http.get<Exemplo[]>(this.url).pipe(
      catchError(this.handleError('listar exemplos'))
    );
  }
  
  buscarPorId(id: string): Observable<Exemplo> {
    return this.http.get<Exemplo>(`${this.url}/${id}`).pipe(
      catchError(this.handleError('buscar exemplo'))
    );
  }
  
  salvar(exemplo: CriarExemploRequest): Observable<Exemplo> {
    return this.http.post<Exemplo>(this.url, exemplo).pipe(
      catchError(this.handleError('salvar exemplo'))
    );
  }
}
```

---

**ğŸš¨ Siga TODAS as regras antes de implementar qualquer funcionalidade.**

Em caso de dÃºvida, consulte `.cursorrules` ou peÃ§a revisÃ£o de arquitetura.
