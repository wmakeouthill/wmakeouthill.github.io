# ğŸ¨ Diretrizes de Desenvolvimento Frontend
## Angular 17+ â€¢ TypeScript â€¢ Clean Architecture

> **Este documento define os princÃ­pios, padrÃµes e regras OBRIGATÃ“RIAS para desenvolvimento frontend.**
> Consulte `.cursorrules` para visÃ£o geral e `.cursorrules-backend` para regras do backend.

---

## ğŸ“‹ ÃNDICE

1. [Stack TecnolÃ³gica](#1-stack-tecnolÃ³gica)
2. [PrincÃ­pios SOLID Aplicados ao Angular](#2-princÃ­pios-solid-aplicados-ao-angular)
3. [Arquitetura de Componentes](#3-arquitetura-de-componentes)
4. [Sintaxe Moderna ObrigatÃ³ria](#4-sintaxe-moderna-obrigatÃ³ria)
5. [Gerenciamento de Estado com Signals](#5-gerenciamento-de-estado-com-signals)
6. [Composables e ReutilizaÃ§Ã£o](#6-composables-e-reutilizaÃ§Ã£o)
7. [OrganizaÃ§Ã£o de CÃ³digo](#7-organizaÃ§Ã£o-de-cÃ³digo)
8. [PadrÃµes de Nomenclatura](#8-padrÃµes-de-nomenclatura)
9. [Clean Code no Frontend](#9-clean-code-no-frontend)
10. [ValidaÃ§Ãµes e FormulÃ¡rios](#10-validaÃ§Ãµes-e-formulÃ¡rios)
11. [Testes](#11-testes)
12. [Anti-Patterns](#12-anti-patterns)
13. [Checklist de Qualidade](#13-checklist-de-qualidade)
14. [SSR e HidrataÃ§Ã£o](#14-ssr-e-hidrataÃ§Ã£o-angular-universal)

---

## 1. STACK TECNOLÃ“GICA

### VersÃµes ObrigatÃ³rias

| Tecnologia   | VersÃ£o      | ObservaÃ§Ã£o                           |
|--------------|-------------|--------------------------------------|
| Angular      | 17.3.0+     | Standalone components obrigatÃ³rio    |
| TypeScript   | 5.4.2+      | Strict mode habilitado               |
| RxJS         | 7.8.0+      | Uso reduzido (preferir Signals)      |

### Recursos ObrigatÃ³rios

```typescript
// âœ… SEMPRE usar estas features
inject()      // InjeÃ§Ã£o de dependÃªncia
signal()      // Estado reativo
computed()    // Valores derivados
input()       // Props de componentes
output()      // Eventos de componentes
effect()      // Efeitos colaterais

// âœ… SEMPRE usar esta sintaxe no HTML
@if, @else    // Condicionais
@for          // Loops
@switch       // Switch case
@defer        // Lazy loading
```

---

## 2. PRINCÃPIOS SOLID APLICADOS AO ANGULAR

### S - Single Responsibility (Responsabilidade Ãšnica)

```typescript
// âœ… CORRETO - Componente faz apenas uma coisa
@Component({ ... })
export class ProdutoCardComponent {
  readonly produto = input.required<Produto>();
  readonly onSelecionar = output<Produto>();
  // Apenas exibe e emite evento
}

// âŒ ERRADO - MÃºltiplas responsabilidades
@Component({ ... })
export class ProdutoComponent {
  // Lista, cria, edita, exclui, valida, formata...
}
```

### O - Open/Closed (Aberto/Fechado)

```typescript
// âœ… CORRETO - ExtensÃ­vel sem modificaÃ§Ã£o
export interface ValidadorProduto {
  validar(produto: Produto): ValidationResult;
}

// Adicione novos validadores sem modificar existentes
export class ValidadorPreco implements ValidadorProduto { ... }
export class ValidadorEstoque implements ValidadorProduto { ... }
```

### L - Liskov Substitution (SubstituiÃ§Ã£o de Liskov)

```typescript
// âœ… CORRETO - Subtipos sÃ£o substituÃ­veis
abstract class BaseFormComponent<T> {
  abstract salvar(): void;
  abstract cancelar(): void;
}

export class ProdutoFormComponent extends BaseFormComponent<Produto> {
  salvar(): void { /* implementaÃ§Ã£o */ }
  cancelar(): void { /* implementaÃ§Ã£o */ }
}
```

### I - Interface Segregation (SegregaÃ§Ã£o de Interfaces)

```typescript
// âœ… CORRETO - Interfaces pequenas e focadas
interface Listavel<T> {
  itens: Signal<T[]>;
  carregar(): void;
}

interface Paginavel {
  paginaAtual: Signal<number>;
  totalPaginas: Signal<number>;
  irParaPagina(pagina: number): void;
}

interface Filtravel<F> {
  filtro: Signal<F>;
  aplicarFiltro(filtro: F): void;
}

// âŒ ERRADO - Interface grande demais
interface CrudCompleto<T, F> {
  itens: Signal<T[]>;
  carregar(): void;
  criar(item: T): void;
  editar(item: T): void;
  excluir(id: string): void;
  filtrar(filtro: F): void;
  paginar(pagina: number): void;
  ordenar(campo: string): void;
  // ... mais 20 mÃ©todos
}
```

### D - Dependency Inversion (InversÃ£o de DependÃªncia)

```typescript
// âœ… CORRETO - Depende de abstraÃ§Ãµes
export class ProdutoListaComponent {
  private readonly produtoService = inject(ProdutoService); // Interface/Token
  // NÃ£o depende de implementaÃ§Ã£o especÃ­fica
}

// Service pode ser mockado facilmente para testes
```

---

## 3. ARQUITETURA DE COMPONENTES

### Estrutura de Pastas

```
src/app/
â”œâ”€â”€ components/                    # Componentes de feature
â”‚   â””â”€â”€ {feature}/
â”‚       â”œâ”€â”€ {feature}.component.ts
â”‚       â”œâ”€â”€ {feature}.component.html
â”‚       â”œâ”€â”€ {feature}.component.css
â”‚       â””â”€â”€ composables/           # LÃ³gica reutilizÃ¡vel da feature
â”‚           â””â”€â”€ use-{nome}.ts
â”œâ”€â”€ shared/                        # Componentes compartilhados
â”‚   â””â”€â”€ components/
â”œâ”€â”€ services/                      # ServiÃ§os de aplicaÃ§Ã£o
â”œâ”€â”€ models/                        # Interfaces e tipos
â”œâ”€â”€ utils/                         # UtilitÃ¡rios puros
â”œâ”€â”€ guards/                        # Guards de rota
â””â”€â”€ interceptors/                  # HTTP Interceptors
```

### Hierarquia de Componentes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Smart Components (Container/Feature)        â”‚
â”‚  - Gerencia estado                          â”‚
â”‚  - Injeta services                          â”‚
â”‚  - Coordena componentes filhos              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dumb Components (Presentational)           â”‚
â”‚  - Recebe dados via input()                 â”‚
â”‚  - Emite eventos via output()               â”‚
â”‚  - Sem lÃ³gica de negÃ³cio                    â”‚
â”‚  - Altamente reutilizÃ¡vel                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. SINTAXE MODERNA OBRIGATÃ“RIA

### 4.1 InjeÃ§Ã£o de DependÃªncia

```typescript
// âœ… CORRETO - inject() moderno
export class ProdutoComponent {
  private readonly produtoService = inject(ProdutoService);
  private readonly router = inject(Router);
  private readonly destroyRef = inject(DestroyRef);
}

// âŒ PROIBIDO - Constructor injection
export class ProdutoComponent {
  constructor(
    private produtoService: ProdutoService,
    private router: Router
  ) {}
}
```

### 4.2 Input/Output Signals

```typescript
// âœ… CORRETO - Nova sintaxe signal-based
export class ProdutoCardComponent {
  // Inputs
  readonly produto = input.required<Produto>();
  readonly destacado = input<boolean>(false);
  readonly tamanho = input<'sm' | 'md' | 'lg'>('md');
  
  // Outputs
  readonly onSelecionar = output<Produto>();
  readonly onEditar = output<string>();
  readonly onExcluir = output<void>();
  
  // Computed baseado em input
  readonly precoFormatado = computed(() => 
    formatarMoeda(this.produto().preco)
  );
}

// âŒ PROIBIDO - Decorators antigos
export class ProdutoCardComponent {
  @Input() produto!: Produto;
  @Input() destacado = false;
  @Output() onSelecionar = new EventEmitter<Produto>();
}
```

### 4.3 Sintaxe de Template

```html
<!-- âœ… CORRETO - Nova sintaxe de controle -->
@if (carregando()) {
  <app-loading />
} @else if (erro()) {
  <app-erro [mensagem]="erro()" />
} @else {
  @for (produto of produtos(); track produto.id) {
    <app-produto-card 
      [produto]="produto" 
      (onSelecionar)="selecionarProduto($event)" 
    />
  } @empty {
    <p>Nenhum produto encontrado.</p>
  }
}

@switch (status()) {
  @case ('pendente') { <span class="badge-warning">Pendente</span> }
  @case ('aprovado') { <span class="badge-success">Aprovado</span> }
  @default { <span class="badge-secondary">Desconhecido</span> }
}

@defer (on viewport) {
  <app-componente-pesado />
} @placeholder {
  <app-skeleton />
} @loading (minimum 500ms) {
  <app-loading />
}

<!-- âŒ PROIBIDO - Sintaxe antiga -->
<div *ngIf="carregando">...</div>
<div *ngFor="let p of produtos">...</div>
<div [ngSwitch]="status">...</div>
```

### 4.4 Standalone Components

```typescript
// âœ… CORRETO - Standalone obrigatÃ³rio
@Component({
  selector: 'app-produto-lista',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    ProdutoCardComponent,  // Importa apenas o necessÃ¡rio
    LoadingComponent
  ],
  templateUrl: './produto-lista.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ProdutoListaComponent { }

// âŒ PROIBIDO - NgModules (exceto casos especÃ­ficos de library)
@NgModule({
  declarations: [...],
  imports: [...],
  exports: [...]
})
export class ProdutoModule { }
```

---

## 5. GERENCIAMENTO DE ESTADO COM SIGNALS

### 5.1 Estado Local do Componente

```typescript
export class ProdutoListaComponent {
  // Estado primitivo
  readonly carregando = signal(false);
  readonly termoBusca = signal('');
  
  // Estado complexo
  readonly produtos = signal<Produto[]>([]);
  readonly produtoSelecionado = signal<Produto | null>(null);
  
  // Valores derivados (computados)
  readonly produtosFiltrados = computed(() => {
    const termo = this.termoBusca().toLowerCase();
    return this.produtos().filter(p => 
      p.nome.toLowerCase().includes(termo)
    );
  });
  
  readonly quantidadeProdutos = computed(() => 
    this.produtosFiltrados().length
  );
  
  readonly temProdutos = computed(() => 
    this.produtosFiltrados().length > 0
  );
}
```

### 5.2 AtualizaÃ§Ã£o de Estado

```typescript
// âœ… CORRETO - set() para substituiÃ§Ã£o completa
this.produtos.set(novosProdutos);

// âœ… CORRETO - update() para mutaÃ§Ãµes baseadas no estado anterior
this.produtos.update(lista => [...lista, novoProduto]);
this.produtos.update(lista => lista.filter(p => p.id !== id));
this.produtos.update(lista => 
  lista.map(p => p.id === produto.id ? produto : p)
);

// âŒ ERRADO - MutaÃ§Ã£o direta (nÃ£o dispara reatividade)
this.produtos().push(novoProduto);
```

### 5.3 Effects para Efeitos Colaterais

```typescript
export class ProdutoComponent {
  readonly filtro = signal<FiltroType>({});
  
  constructor() {
    // âœ… CORRETO - Effect no contexto de injeÃ§Ã£o
    effect(() => {
      const filtroAtual = this.filtro();
      console.log('Filtro alterado:', filtroAtual);
      this.carregarProdutos(filtroAtual);
    });
  }
  
  // Para effects fora do constructor
  private readonly destroyRef = inject(DestroyRef);
  
  ngOnInit() {
    // Effect com cleanup
    effect((onCleanup) => {
      const subscription = this.algumObservable$.subscribe();
      onCleanup(() => subscription.unsubscribe());
    }, { injector: inject(Injector) });
  }
}
```

### 5.4 Quando NÃƒO Usar Signals

```typescript
// âœ… Use RxJS para:
// - Streams de eventos (WebSocket, Server-Sent Events)
// - OperaÃ§Ãµes complexas de debounce/throttle
// - CombinaÃ§Ã£o complexa de mÃºltiplas streams assÃ­ncronas

// âœ… Use variÃ¡veis simples para:
// - Valores que nunca mudam
// - ConfiguraÃ§Ãµes estÃ¡ticas
readonly MAX_ITENS = 100;
readonly COLUNAS_TABELA = ['nome', 'preco', 'categoria'];
```

---

## 6. COMPOSABLES E REUTILIZAÃ‡ÃƒO

### 6.1 PadrÃ£o de Composable

```typescript
// src/app/components/gestao-caixa/composables/use-movimentacoes.ts

export function useMovimentacoes() {
  // InjeÃ§Ã£o de dependÃªncias
  const caixaService = inject(GestaoCaixaService);
  const notificationService = inject(NotificationService);
  
  // Estado encapsulado
  const movimentacoes = signal<Movimentacao[]>([]);
  const carregando = signal(false);
  const erro = signal<string | null>(null);
  
  // Computeds
  const totalEntradas = computed(() =>
    movimentacoes()
      .filter(m => m.tipo === 'ENTRADA')
      .reduce((acc, m) => acc + m.valor, 0)
  );
  
  const totalSaidas = computed(() =>
    movimentacoes()
      .filter(m => m.tipo === 'SAIDA')
      .reduce((acc, m) => acc + m.valor, 0)
  );
  
  const saldo = computed(() => totalEntradas() - totalSaidas());
  
  // AÃ§Ãµes
  async function carregar(sessaoId: string): Promise<void> {
    carregando.set(true);
    erro.set(null);
    
    try {
      const dados = await firstValueFrom(
        caixaService.buscarMovimentacoes(sessaoId)
      );
      movimentacoes.set(dados);
    } catch (e) {
      erro.set('Erro ao carregar movimentaÃ§Ãµes');
      notificationService.erro('Erro ao carregar movimentaÃ§Ãµes');
    } finally {
      carregando.set(false);
    }
  }
  
  async function adicionar(movimentacao: CriarMovimentacao): Promise<boolean> {
    try {
      const nova = await firstValueFrom(
        caixaService.criarMovimentacao(movimentacao)
      );
      movimentacoes.update(lista => [...lista, nova]);
      notificationService.sucesso('MovimentaÃ§Ã£o registrada');
      return true;
    } catch (e) {
      notificationService.erro('Erro ao registrar movimentaÃ§Ã£o');
      return false;
    }
  }
  
  // Retorna API pÃºblica
  return {
    // Estado (readonly para consumidor)
    movimentacoes: movimentacoes.asReadonly(),
    carregando: carregando.asReadonly(),
    erro: erro.asReadonly(),
    totalEntradas,
    totalSaidas,
    saldo,
    
    // AÃ§Ãµes
    carregar,
    adicionar
  };
}
```

### 6.2 Uso do Composable

```typescript
@Component({
  selector: 'app-gestao-caixa',
  standalone: true,
  // ...
})
export class GestaoCaixaComponent {
  private readonly movimentacoes = useMovimentacoes();
  
  // Expor para o template
  readonly listaMovimentacoes = this.movimentacoes.movimentacoes;
  readonly carregando = this.movimentacoes.carregando;
  readonly saldo = this.movimentacoes.saldo;
  
  constructor() {
    effect(() => {
      const sessaoId = this.sessaoAtual()?.id;
      if (sessaoId) {
        this.movimentacoes.carregar(sessaoId);
      }
    });
  }
  
  async registrarMovimentacao(dados: CriarMovimentacao): Promise<void> {
    await this.movimentacoes.adicionar(dados);
  }
}
```

### 6.3 Composables UtilitÃ¡rios

```typescript
// use-paginacao.ts
export function usePaginacao<T>(itens: Signal<T[]>, itensPorPagina = 10) {
  const paginaAtual = signal(1);
  
  const totalPaginas = computed(() => 
    Math.ceil(itens().length / itensPorPagina)
  );
  
  const itensPaginados = computed(() => {
    const inicio = (paginaAtual() - 1) * itensPorPagina;
    return itens().slice(inicio, inicio + itensPorPagina);
  });
  
  function irParaPagina(pagina: number): void {
    if (pagina >= 1 && pagina <= totalPaginas()) {
      paginaAtual.set(pagina);
    }
  }
  
  return {
    paginaAtual: paginaAtual.asReadonly(),
    totalPaginas,
    itensPaginados,
    irParaPagina,
    proximaPagina: () => irParaPagina(paginaAtual() + 1),
    paginaAnterior: () => irParaPagina(paginaAtual() - 1)
  };
}

// use-debounce.ts
export function useDebounce<T>(valorInicial: T, delay = 300) {
  const valor = signal(valorInicial);
  const valorDebounced = signal(valorInicial);
  
  let timeoutId: ReturnType<typeof setTimeout>;
  
  effect(() => {
    const valorAtual = valor();
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      valorDebounced.set(valorAtual);
    }, delay);
  });
  
  return {
    valor,
    valorDebounced: valorDebounced.asReadonly()
  };
}
```

---

## 7. ORGANIZAÃ‡ÃƒO DE CÃ“DIGO

### 7.1 Ordem dos Membros do Componente

```typescript
@Component({ ... })
export class ExemploComponent {
  // 1. InjeÃ§Ãµes de dependÃªncia
  private readonly service = inject(ExemploService);
  private readonly router = inject(Router);
  
  // 2. Inputs
  readonly item = input.required<Item>();
  readonly modo = input<'edicao' | 'visualizacao'>('visualizacao');
  
  // 3. Outputs
  readonly onSalvar = output<Item>();
  readonly onCancelar = output<void>();
  
  // 4. Signals de estado
  readonly carregando = signal(false);
  readonly erro = signal<string | null>(null);
  
  // 5. Computeds
  readonly itemValido = computed(() => this.validarItem(this.item()));
  readonly podeSalvar = computed(() => !this.carregando() && this.itemValido());
  
  // 6. Constructor com effects
  constructor() {
    effect(() => { /* ... */ });
  }
  
  // 7. Lifecycle hooks
  ngOnInit(): void { }
  ngOnDestroy(): void { }
  
  // 8. MÃ©todos pÃºblicos (aÃ§Ãµes do template)
  salvar(): void { }
  cancelar(): void { }
  
  // 9. MÃ©todos privados (lÃ³gica interna)
  private validarItem(item: Item): boolean { }
  private processarDados(): void { }
}
```

### 7.2 OrganizaÃ§Ã£o de Arquivos por Feature

```
components/
â””â”€â”€ gestao-caixa/
    â”œâ”€â”€ gestao-caixa.component.ts      # Container principal
    â”œâ”€â”€ gestao-caixa.component.html
    â”œâ”€â”€ gestao-caixa.component.css
    â”œâ”€â”€ composables/
    â”‚   â”œâ”€â”€ use-movimentacoes.ts       # LÃ³gica de movimentaÃ§Ãµes
    â”‚   â”œâ”€â”€ use-sessao-caixa.ts        # LÃ³gica de sessÃ£o
    â”‚   â””â”€â”€ use-sugestoes-descricao.ts # Autocomplete
    â”œâ”€â”€ components/                     # Sub-componentes
    â”‚   â”œâ”€â”€ movimentacao-form/
    â”‚   â”œâ”€â”€ movimentacao-lista/
    â”‚   â””â”€â”€ resumo-caixa/
    â””â”€â”€ models/                         # Tipos especÃ­ficos da feature
        â””â”€â”€ movimentacao.types.ts
```

---

## 8. PADRÃ•ES DE NOMENCLATURA

### 8.1 Arquivos

| Tipo                  | PadrÃ£o                           | Exemplo                         |
|-----------------------|----------------------------------|---------------------------------|
| Componente            | `{nome}.component.ts`            | `produto-lista.component.ts`    |
| Service               | `{nome}.service.ts`              | `produto.service.ts`            |
| Composable            | `use-{nome}.ts`                  | `use-paginacao.ts`              |
| Model/Interface       | `{nome}.model.ts`                | `produto.model.ts`              |
| UtilitÃ¡rio            | `{nome}.util.ts`                 | `formato.util.ts`               |
| Guard                 | `{nome}.guard.ts`                | `auth.guard.ts`                 |
| Interceptor           | `{nome}.interceptor.ts`          | `error.interceptor.ts`          |

### 8.2 Classes e Interfaces

```typescript
// Classes: PascalCase + sufixo do tipo
export class ProdutoService { }
export class ProdutoListaComponent { }
export class AuthGuard { }

// Interfaces: PascalCase (sem prefixo I)
export interface Produto { }
export interface FiltrosProduto { }
export interface RespostaPaginada<T> { }

// Types: PascalCase + sufixo Type quando apropriado
export type StatusPedido = 'pendente' | 'preparando' | 'pronto';
export type ProdutoFormType = FormGroup<ProdutoFormControls>;
```

### 8.3 VariÃ¡veis e FunÃ§Ãµes

```typescript
// Signals: substantivos descritivos
readonly produtos = signal<Produto[]>([]);
readonly produtoSelecionado = signal<Produto | null>(null);
readonly carregandoProdutos = signal(false);

// Computeds: substantivos ou adjetivos
readonly produtosFiltrados = computed(() => ...);
readonly temProdutos = computed(() => ...);
readonly podeEditar = computed(() => ...);

// FunÃ§Ãµes/MÃ©todos: verbos no infinitivo
function carregarProdutos(): void { }
function salvarProduto(produto: Produto): Promise<void> { }
function validarFormulario(): boolean { }

// Handlers de eventos: on + aÃ§Ã£o
function onProdutoSelecionado(produto: Produto): void { }
function onFormularioSubmit(): void { }

// âŒ PROIBIDO
let data: any;      // Nome genÃ©rico
let p: Produto;     // AbreviaÃ§Ã£o
let handleClick();  // "handle" nÃ£o Ã© portuguÃªs
```

### 8.4 Constantes

```typescript
// Constantes: UPPER_SNAKE_CASE
export const MAX_UPLOAD_SIZE = 5 * 1024 * 1024;
export const API_BASE_URL = '/api';
export const DEBOUNCE_TIME_MS = 300;

// Enums: PascalCase para nome, UPPER_SNAKE_CASE para valores
export enum StatusPedido {
  PENDENTE = 'PENDENTE',
  EM_PREPARO = 'EM_PREPARO',
  PRONTO = 'PRONTO',
  ENTREGUE = 'ENTREGUE'
}
```

---

## 9. CLEAN CODE NO FRONTEND

### 9.1 Tamanho de Arquivos

| Tipo        | MÃ¡ximo Recomendado | Limite Absoluto |
|-------------|-------------------|-----------------|
| Componente  | 150 linhas        | 300 linhas      |
| Composable  | 100 linhas        | 200 linhas      |
| Service     | 150 linhas        | 300 linhas      |
| UtilitÃ¡rio  | 100 linhas        | 200 linhas      |

### 9.2 Tamanho de FunÃ§Ãµes

```typescript
// âœ… CORRETO - FunÃ§Ãµes pequenas e focadas
async function carregarProdutos(): Promise<void> {
  carregando.set(true);
  try {
    const produtos = await buscarProdutosApi();
    processarProdutos(produtos);
  } finally {
    carregando.set(false);
  }
}

function processarProdutos(produtos: Produto[]): void {
  const validados = validarProdutos(produtos);
  const ordenados = ordenarPorNome(validados);
  this.produtos.set(ordenados);
}

// âŒ ERRADO - FunÃ§Ã£o fazendo muitas coisas
async function carregarEProcessarEExibirProdutos(): Promise<void> {
  // 50 linhas de cÃ³digo fazendo tudo
}
```

### 9.3 DRY no Frontend

```typescript
// âœ… CORRETO - Reutilizar utilitÃ¡rios existentes
import { formatarMoeda, formatarData } from '../../utils/formato.util';
import { validarCPF, validarEmail } from '../../utils/validacao.util';

// âœ… CORRETO - Criar composables para lÃ³gica repetida
const { itens, carregar, adicionar } = useCrudGenerico<Produto>();

// âŒ ERRADO - Duplicar cÃ³digo
// Em ProdutoComponent:
formatarValor(valor: number): string {
  return 'R$ ' + valor.toFixed(2).replace('.', ',');
}
// Em PedidoComponent (mesmo cÃ³digo):
formatarPreco(preco: number): string {
  return 'R$ ' + preco.toFixed(2).replace('.', ',');
}
```

---

## 10. VALIDAÃ‡Ã•ES E FORMULÃRIOS

### 10.1 FormulÃ¡rios Tipados

```typescript
interface ProdutoForm {
  nome: FormControl<string>;
  preco: FormControl<number>;
  categoria: FormControl<string>;
  ativo: FormControl<boolean>;
}

export class ProdutoFormComponent {
  readonly form = new FormGroup<ProdutoForm>({
    nome: new FormControl('', {
      nonNullable: true,
      validators: [Validators.required, Validators.minLength(3)]
    }),
    preco: new FormControl(0, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(0.01)]
    }),
    categoria: new FormControl('', {
      nonNullable: true,
      validators: [Validators.required]
    }),
    ativo: new FormControl(true, { nonNullable: true })
  });
  
  readonly formValido = computed(() => this.form.valid);
}
```

### 10.2 Validadores Customizados

```typescript
// src/app/utils/validadores.util.ts
export function validadorCPF(): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    if (!control.value) return null;
    const valido = validarCPF(control.value);
    return valido ? null : { cpfInvalido: true };
  };
}

export function validadorPrecoMinimo(minimo: number): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    if (control.value < minimo) {
      return { precoMinimo: { minimo, atual: control.value } };
    }
    return null;
  };
}
```

### 10.3 Mensagens de Erro

```typescript
// Centralizar mensagens de erro
const MENSAGENS_ERRO: Record<string, string> = {
  required: 'Campo obrigatÃ³rio',
  minlength: 'MÃ­nimo de {requiredLength} caracteres',
  min: 'Valor mÃ­nimo: {min}',
  email: 'E-mail invÃ¡lido',
  cpfInvalido: 'CPF invÃ¡lido'
};

export function obterMensagemErro(errors: ValidationErrors | null): string {
  if (!errors) return '';
  const primeiroErro = Object.keys(errors)[0];
  const mensagem = MENSAGENS_ERRO[primeiroErro] || 'Campo invÃ¡lido';
  return mensagem.replace(/{(\w+)}/g, (_, key) => errors[primeiroErro][key]);
}
```

---

## 11. TESTES

### 11.1 Estrutura de Testes

```typescript
describe('ProdutoListaComponent', () => {
  let component: ProdutoListaComponent;
  let produtoService: jasmine.SpyObj<ProdutoService>;
  
  beforeEach(async () => {
    produtoService = jasmine.createSpyObj('ProdutoService', ['buscarTodos']);
    
    await TestBed.configureTestingModule({
      imports: [ProdutoListaComponent],
      providers: [
        { provide: ProdutoService, useValue: produtoService }
      ]
    }).compileComponents();
    
    component = TestBed.createComponent(ProdutoListaComponent).componentInstance;
  });
  
  describe('carregamento inicial', () => {
    it('deve exibir loading enquanto carrega', () => {
      // Arrange
      produtoService.buscarTodos.and.returnValue(of([]).pipe(delay(100)));
      
      // Act
      component.ngOnInit();
      
      // Assert
      expect(component.carregando()).toBeTrue();
    });
    
    it('deve carregar e exibir produtos', fakeAsync(() => {
      // Arrange
      const produtos = [criarProdutoMock(), criarProdutoMock()];
      produtoService.buscarTodos.and.returnValue(of(produtos));
      
      // Act
      component.ngOnInit();
      tick();
      
      // Assert
      expect(component.produtos()).toEqual(produtos);
      expect(component.carregando()).toBeFalse();
    }));
  });
});
```

### 11.2 Testes de Composables

```typescript
describe('useMovimentacoes', () => {
  it('deve calcular saldo corretamente', () => {
    TestBed.runInInjectionContext(() => {
      const composable = useMovimentacoes();
      
      // Simular dados
      composable.movimentacoes.set([
        { tipo: 'ENTRADA', valor: 100 },
        { tipo: 'SAIDA', valor: 30 },
        { tipo: 'ENTRADA', valor: 50 }
      ]);
      
      expect(composable.totalEntradas()).toBe(150);
      expect(composable.totalSaidas()).toBe(30);
      expect(composable.saldo()).toBe(120);
    });
  });
});
```

---

## 12. ANTI-PATTERNS

### âŒ ProibiÃ§Ãµes Absolutas

1. **Constructor injection** ao invÃ©s de `inject()`
2. **Decorators `@Input()` e `@Output()`** ao invÃ©s de `input()` e `output()`
3. **Diretivas `*ngIf`, `*ngFor`** ao invÃ©s de `@if`, `@for`
4. **NgModules** ao invÃ©s de standalone components
5. **BehaviorSubject** para estado simples (use Signals)
6. **`any` sem tipagem** adequada
7. **Componentes com mais de 300 linhas**
8. **LÃ³gica de negÃ³cio em templates**
9. **Strings mÃ¡gicas** espalhadas pelo cÃ³digo
10. **MutaÃ§Ã£o direta de signals** (`this.lista().push()`)

### âš ï¸ Code Smells a Evitar

```typescript
// âŒ MÃºltiplas responsabilidades
export class GodComponent {
  // CRUD completo + validaÃ§Ãµes + formataÃ§Ã£o + navegaÃ§Ã£o
}

// âŒ Prop drilling excessivo
<app-a [dados]="dados">
  <app-b [dados]="dados">
    <app-c [dados]="dados">
      <app-d [dados]="dados" />
    </app-c>
  </app-b>
</app-a>

// âŒ LÃ³gica complexa no template
@if (usuario && usuario.permissoes && usuario.permissoes.includes('admin') && !carregando) {
  ...
}

// âœ… CORRETO - Extrair para computed
readonly podeVerAdmin = computed(() => 
  this.usuario()?.permissoes?.includes('admin') && !this.carregando()
);
```

---

## 13. CHECKLIST DE QUALIDADE

### Antes de Criar um Componente

- [ ] Verificar se nÃ£o existe componente similar
- [ ] Verificar se pode usar composable existente
- [ ] Definir se Ã© Smart ou Dumb component
- [ ] Planejar inputs, outputs e estado

### Antes de Commitar

- [ ] Todos os componentes sÃ£o standalone
- [ ] Usando `inject()` para DI
- [ ] Usando `signal()`, `computed()`, `input()`, `output()`
- [ ] Usando `@if`, `@for`, `@switch` no template
- [ ] ChangeDetection.OnPush habilitado
- [ ] Arquivo com menos de 300 linhas
- [ ] FunÃ§Ãµes com menos de 20 linhas
- [ ] Sem cÃ³digo duplicado
- [ ] Nomes descritivos e autoexplicativos
- [ ] Tipos bem definidos (sem `any`)
- [ ] Imports organizados e otimizados

---

## 14. SSR E HIDRATAÃ‡ÃƒO (Angular Universal)

### âš ï¸ REGRAS CRÃTICAS PARA EVITAR ERROS DE HIDRATAÃ‡ÃƒO (NG0506)

O Angular SSR (Server-Side Rendering) renderiza a aplicaÃ§Ã£o no servidor antes de enviar ao browser.
A **hidrataÃ§Ã£o** Ã© o processo de "ativar" o HTML estÃ¡tico no cliente.

#### Erros Comuns e Como Evitar

**Erro NG0506:** `ApplicationRef.isStable() nÃ£o emitiu true dentro de 10000ms`

Este erro ocorre quando hÃ¡ operaÃ§Ãµes assÃ­ncronas pendentes que impedem a estabilizaÃ§Ã£o da aplicaÃ§Ã£o.

#### Causas Principais

1. **RequisiÃ§Ãµes HTTP no servidor** - Subscriptions que nunca completam
2. **setInterval/setTimeout** - Timers que nÃ£o sÃ£o limpos
3. **Observables infinitos** - Streams que nunca completam
4. **WebSocket/EventSource** - ConexÃµes persistentes

#### Regras ObrigatÃ³rias

```typescript
// âœ… CORRETO - Verificar se estÃ¡ no browser antes de fazer requisiÃ§Ãµes HTTP em ngOnInit
@Component({ ... })
export class MeuComponent implements OnInit {
  private readonly platformId = inject(PLATFORM_ID);
  private readonly isBrowser = isPlatformBrowser(this.platformId);

  ngOnInit(): void {
    // RequisiÃ§Ãµes HTTP apenas no browser
    if (this.isBrowser) {
      this.carregarDados();
    }
  }
}

// âœ… CORRETO - Composables que fazem HTTP devem ser chamados apenas no browser
export function useMinhaFeature() {
  // FunÃ§Ãµes que fazem HTTP nÃ£o devem ser chamadas automaticamente
  // O componente que usa o composable deve verificar isBrowser
  function carregarDados(): void {
    service.buscarDados().subscribe({ ... });
  }

  return { carregarDados, ... };
}

// No componente:
ngOnInit(): void {
  if (this.isBrowser) {
    this.meuComposable.carregarDados();
  }
}

// âœ… CORRETO - Usar @defer para lazy loading de conteÃºdo pesado
@defer (on viewport) {
  <componente-pesado />
} @placeholder {
  <div class="skeleton"></div>
}

// âŒ ERRADO - Fazer requisiÃ§Ã£o HTTP no servidor sem controle
ngOnInit(): void {
  this.http.get('/api/dados').subscribe(); // Pode travar hidrataÃ§Ã£o!
}

// âŒ ERRADO - Criar interval/timeout sem limpar
ngOnInit(): void {
  setInterval(() => { ... }, 1000); // Nunca para!
}
```

#### PadrÃ£o para Modais com Dados AssÃ­ncronos

```typescript
// âœ… CORRETO - Carregar dados apenas quando modal Ã© aberto (aÃ§Ã£o do usuÃ¡rio)
function abrirModal(): void {
  mostrarModal.set(true);
  carregarDados(); // OK: aÃ§Ã£o do usuÃ¡rio, jÃ¡ estÃ¡ no browser
}

// âœ… CORRETO - NÃ£o carregar dados automaticamente em composables
export function useEstatisticas() {
  // NÃƒO chame carregarEstatisticas() automaticamente aqui
  // Deixe o componente decidir quando carregar

  function abrirModal(): void {
    mostrarModal.set(true);
    carregarEstatisticas(); // Carrega apenas quando usuÃ¡rio abre
  }

  return { abrirModal, ... };
}
```

#### ğŸ”¥ REGRA CRÃTICA: Timers e Polling com NgZone.runOutsideAngular

**PROBLEMA:** Timers (`setInterval`, `timer()`) que nunca completam impedem `ApplicationRef.isStable()`
de emitir `true`, causando o erro NG0506 de timeout de hidrataÃ§Ã£o.

**SOLUÃ‡ÃƒO:** Use `NgZone.runOutsideAngular()` para executar timers fora da zona Angular,
e `NgZone.run()` para atualizar estado dentro da zona (trigger change detection).

```typescript
// âœ… CORRETO - Timer/Polling fora da zona Angular
@Injectable({ providedIn: 'root' })
export class MeuPollingService {
  private readonly ngZone = inject(NgZone);
  private readonly http = inject(HttpClient);
  
  readonly dados = signal<Dados[]>([]);
  private subscription: Subscription | null = null;

  iniciarPolling(): void {
    // Executa o timer FORA da zona Angular
    this.ngZone.runOutsideAngular(() => {
      this.subscription = timer(0, 5000).pipe(
        switchMap(() => this.http.get<Dados[]>('/api/dados'))
      ).subscribe(resultado => {
        // Atualiza estado DENTRO da zona para trigger change detection
        this.ngZone.run(() => this.dados.set(resultado));
      });
    });
  }

  pararPolling(): void {
    this.subscription?.unsubscribe();
  }
}

// âœ… CORRETO - setInterval em componentes fora da zona
@Component({ ... })
export class MeuComponent implements OnDestroy {
  private readonly ngZone = inject(NgZone);
  private intervalId: any = null;

  iniciar(): void {
    this.ngZone.runOutsideAngular(() => {
      this.intervalId = setInterval(() => {
        this.ngZone.run(() => this.atualizarEstado());
      }, 3000);
    });
  }

  ngOnDestroy(): void {
    if (this.intervalId) clearInterval(this.intervalId);
  }
}

// âŒ ERRADO - Timer dentro da zona Angular (bloqueia estabilidade!)
iniciarPolling(): void {
  timer(0, 5000).pipe(
    switchMap(() => this.http.get('/api/dados'))
  ).subscribe(resultado => {
    this.dados.set(resultado); // âš ï¸ Nunca estabiliza!
  });
}

// âŒ ERRADO - setInterval sem NgZone (bloqueia estabilidade!)
ngOnInit(): void {
  setInterval(() => this.refresh(), 3000); // âš ï¸ Erro NG0506!
}
```

**Quando usar `runOutsideAngular()`:**
- `setInterval()` / `clearInterval()`
- `timer()` / `interval()` do RxJS que nÃ£o completam
- WebSocket connections
- Polling de APIs
- AnimaÃ§Ãµes contÃ­nuas com `requestAnimationFrame`

**Quando NÃƒO usar:**
- RequisiÃ§Ãµes HTTP Ãºnicas (completam naturalmente)
- `setTimeout` curtos (< 5 segundos)
- Observables que completam apÃ³s emitir

#### Checklist SSR

- [ ] Verificar `isPlatformBrowser()` antes de requisiÃ§Ãµes HTTP em `ngOnInit`
- [ ] Nunca fazer requisiÃ§Ãµes HTTP automÃ¡ticas em construtores/composables
- [ ] **Usar `NgZone.runOutsideAngular()` para timers/polling que nÃ£o completam**
- [ ] **Usar `NgZone.run()` dentro do timer para atualizar estado/signals**
- [ ] Usar `@defer` para componentes pesados
- [ ] Limpar timers e subscriptions no `ngOnDestroy`
- [ ] Modais devem carregar dados apenas quando abertos (aÃ§Ã£o do usuÃ¡rio)
- [ ] Evitar uso de `document`, `window`, `localStorage` sem verificar browser

---

## ğŸ“š RECURSOS DO PROJETO

### UtilitÃ¡rios DisponÃ­veis

```typescript
// src/app/utils/
import { formatarMoeda, formatarData } from './formato.util';
import { validarCPF, validarEmail } from './validacao.util';
import { paginar, ordenar } from './paginacao.util';
import { gerarChartConfig } from './chart.util';
import { filtrarPorTermo } from './filtro.util';
```

### Composables Existentes

Verifique em `components/{feature}/composables/` antes de criar novos.

---

**ğŸš¨ LEMBRE-SE: CÃ³digo Angular moderno Ã© declarativo, reativo e altamente tipado!**
