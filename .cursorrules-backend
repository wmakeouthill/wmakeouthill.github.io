# â˜• Diretrizes de Desenvolvimento Backend
## Java 17 â€¢ Spring Boot 3 â€¢ Clean Architecture â€¢ DDD

> **Este documento define os princÃ­pios, padrÃµes e regras OBRIGATÃ“RIAS para desenvolvimento backend.**
> Consulte `.cursorrules` para visÃ£o geral e `.cursorrules-frontend` para regras do frontend.

---

## ğŸ“‹ ÃNDICE

1. [Stack TecnolÃ³gica](#1-stack-tecnolÃ³gica)
2. [Clean Architecture](#2-clean-architecture)
3. [Domain-Driven Design (DDD)](#3-domain-driven-design-ddd)
4. [PrincÃ­pios SOLID](#4-princÃ­pios-solid)
5. [Estrutura de Pacotes](#5-estrutura-de-pacotes)
6. [Camada Domain](#6-camada-domain)
7. [Camada Application](#7-camada-application)
8. [Camada Infrastructure](#8-camada-infrastructure)
9. [Lombok e Java 17](#9-lombok-e-java-17)
10. [Mappers e ConversÃµes](#10-mappers-e-conversÃµes)
11. [PersistÃªncia e RepositÃ³rios](#11-persistÃªncia-e-repositÃ³rios)
12. [ValidaÃ§Ãµes e ExceÃ§Ãµes](#12-validaÃ§Ãµes-e-exceÃ§Ãµes)
13. [MigraÃ§Ãµes com Liquibase](#13-migraÃ§Ãµes-com-liquibase)
14. [Testes](#14-testes)
15. [Anti-Patterns](#15-anti-patterns)
16. [Checklist de Qualidade](#16-checklist-de-qualidade)

---

## 1. STACK TECNOLÃ“GICA

### VersÃµes ObrigatÃ³rias

| Tecnologia   | VersÃ£o      | ObservaÃ§Ã£o                           |
|--------------|-------------|--------------------------------------|
| Java         | 17          | LTS - versÃ£o exata                   |
| Spring Boot  | 3.2.3+      | WebFlux ou MVC                       |
| Liquibase    | 4.25.0+     | MigraÃ§Ãµes de banco                   |
| Maven        | 3.8+        | Build tool padrÃ£o                    |
| MySQL        | 8.0+        | Banco de dados                       |
| Lombok       | Latest      | ReduÃ§Ã£o de boilerplate               |

### DependÃªncias Compartilhadas

```xml
<!-- Sempre usar kernel-compartilhado -->
<dependency>
    <groupId>com.snackbar</groupId>
    <artifactId>kernel-compartilhado</artifactId>
    <version>${project.version}</version>
</dependency>
```

---

## 2. CLEAN ARCHITECTURE

### 2.1 VisÃ£o Geral

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      INFRASTRUCTURE                          â”‚
â”‚  Controllers, Repositories, External Services, Config        â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     APPLICATION                        â”‚  â”‚
â”‚  â”‚       Use Cases, DTOs, Application Services            â”‚  â”‚
â”‚  â”‚                                                        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚                    DOMAIN                        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚    Entities, Value Objects, Domain Services      â”‚  â”‚  â”‚
â”‚  â”‚  â”‚         âŒ ZERO dependÃªncias externas            â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Regra de DependÃªncia (INVIOLÃVEL)

```
Infrastructure  â†’  Application  â†’  Domain
     â†“                  â†“             â†“
  Frameworks         Ports        Entidades
  BD, Web, etc.    Interfaces    Value Objects
                   Use Cases     Regras NegÃ³cio
```

âœ… **Camadas externas DEPENDEM de camadas internas**
âŒ **Camadas internas NUNCA dependem de camadas externas**

### 2.3 Regras por Camada

| Camada         | Pode Depender De        | NÃƒO Pode Depender De        |
|----------------|------------------------|-----------------------------|
| Domain         | Nada (Ã© o nÃºcleo)      | Application, Infrastructure |
| Application    | Domain                 | Infrastructure              |
| Infrastructure | Application, Domain    | -                           |

---

## 3. DOMAIN-DRIVEN DESIGN (DDD)

### 3.1 Building Blocks

```
Domain/
â”œâ”€â”€ entities/           # Entidades com identidade
â”œâ”€â”€ valueobjects/       # Objetos imutÃ¡veis sem identidade
â”œâ”€â”€ aggregates/         # Clusters de entidades (se aplicÃ¡vel)
â”œâ”€â”€ services/           # LÃ³gica de domÃ­nio entre entidades
â”œâ”€â”€ events/             # Eventos de domÃ­nio
â””â”€â”€ exceptions/         # ExceÃ§Ãµes de domÃ­nio
```

### 3.2 Entidades

```java
// âœ… CORRETO - Entidade rica com comportamento
public class Pedido {
    private final String id;
    private final List<ItemPedido> itens;
    private StatusPedido status;
    private final Instant criadoEm;
    
    // Construtor privado - use factory method
    private Pedido(String id, List<ItemPedido> itens) {
        this.id = id;
        this.itens = new ArrayList<>(itens);
        this.status = StatusPedido.PENDENTE;
        this.criadoEm = Instant.now();
    }
    
    // Factory method - Ãºnico ponto de criaÃ§Ã£o
    public static Pedido criar(List<ItemPedido> itens) {
        validarItens(itens);
        return new Pedido(UUID.randomUUID().toString(), itens);
    }
    
    // Comportamento de negÃ³cio na entidade
    public void confirmar() {
        if (this.status != StatusPedido.PENDENTE) {
            throw new EstadoInvalidoException("Pedido nÃ£o pode ser confirmado");
        }
        this.status = StatusPedido.CONFIRMADO;
    }
    
    public void adicionarItem(ItemPedido item) {
        validarPodeModificar();
        this.itens.add(item);
    }
    
    public BigDecimal calcularTotal() {
        return itens.stream()
            .map(ItemPedido::getSubtotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    // ValidaÃ§Ã£o de invariantes
    private static void validarItens(List<ItemPedido> itens) {
        if (itens == null || itens.isEmpty()) {
            throw new RegraDeNegocioException("Pedido deve ter ao menos um item");
        }
    }
    
    private void validarPodeModificar() {
        if (this.status != StatusPedido.PENDENTE) {
            throw new EstadoInvalidoException("Pedido nÃ£o pode ser modificado");
        }
    }
    
    // Getters - NUNCA setters pÃºblicos
    public String getId() { return id; }
    public List<ItemPedido> getItens() { return Collections.unmodifiableList(itens); }
    public StatusPedido getStatus() { return status; }
}

// âŒ ERRADO - Entidade anÃªmica (apenas dados)
public class Pedido {
    private String id;
    private List<ItemPedido> itens;
    private StatusPedido status;
    
    // Getters e setters...
    public void setStatus(StatusPedido status) { this.status = status; }
    public void setItens(List<ItemPedido> itens) { this.itens = itens; }
}
```

### 3.3 Value Objects

```java
// âœ… CORRETO - Value Object imutÃ¡vel com validaÃ§Ã£o
public record Preco(BigDecimal valor) {
    
    public Preco {
        if (valor == null || valor.compareTo(BigDecimal.ZERO) < 0) {
            throw new ValorInvalidoException("PreÃ§o deve ser positivo");
        }
    }
    
    public static Preco of(BigDecimal valor) {
        return new Preco(valor);
    }
    
    public static Preco zero() {
        return new Preco(BigDecimal.ZERO);
    }
    
    public Preco somar(Preco outro) {
        return new Preco(this.valor.add(outro.valor));
    }
    
    public Preco multiplicar(int quantidade) {
        return new Preco(this.valor.multiply(BigDecimal.valueOf(quantidade)));
    }
    
    public boolean maiorQue(Preco outro) {
        return this.valor.compareTo(outro.valor) > 0;
    }
}

// âœ… CORRETO - Value Object para CPF
public record CPF(String valor) {
    
    private static final Pattern PATTERN = Pattern.compile("\\d{11}");
    
    public CPF {
        String limpo = valor.replaceAll("[^0-9]", "");
        if (!PATTERN.matcher(limpo).matches() || !validarDigitos(limpo)) {
            throw new CPFInvalidoException(valor);
        }
        valor = limpo; // Armazena apenas nÃºmeros
    }
    
    public static CPF of(String valor) {
        return new CPF(valor);
    }
    
    public String formatado() {
        return valor.substring(0, 3) + "." + 
               valor.substring(3, 6) + "." + 
               valor.substring(6, 9) + "-" + 
               valor.substring(9);
    }
    
    private static boolean validarDigitos(String cpf) {
        // LÃ³gica de validaÃ§Ã£o de dÃ­gitos verificadores
    }
}
```

### 3.4 Domain Services

```java
// âœ… CORRETO - LÃ³gica que nÃ£o pertence a uma entidade especÃ­fica
public class CalculadoraDescontoService {
    
    public BigDecimal calcularDesconto(Pedido pedido, Cliente cliente) {
        BigDecimal total = pedido.calcularTotal();
        BigDecimal desconto = BigDecimal.ZERO;
        
        // Desconto por fidelidade
        if (cliente.ehFidelidade()) {
            desconto = desconto.add(total.multiply(new BigDecimal("0.05")));
        }
        
        // Desconto por valor
        if (total.compareTo(new BigDecimal("100")) > 0) {
            desconto = desconto.add(total.multiply(new BigDecimal("0.10")));
        }
        
        return desconto;
    }
}
```

---

## 4. PRINCÃPIOS SOLID

### S - Single Responsibility

```java
// âœ… CORRETO - Uma responsabilidade por classe
@Service
@RequiredArgsConstructor
public class CriarPedidoUseCase {
    private final PedidoRepositoryPort repository;
    
    public PedidoDTO executar(CriarPedidoRequest request) {
        // Apenas criaÃ§Ã£o de pedido
    }
}

@Service
@RequiredArgsConstructor
public class CancelarPedidoUseCase {
    private final PedidoRepositoryPort repository;
    private final NotificacaoPort notificacao;
    
    public void executar(String pedidoId) {
        // Apenas cancelamento de pedido
    }
}

// âŒ ERRADO - MÃºltiplas responsabilidades
@Service
public class PedidoService {
    public PedidoDTO criar(...) { }
    public void cancelar(...) { }
    public void atualizar(...) { }
    public List<PedidoDTO> buscarTodos(...) { }
    public void enviarNotificacao(...) { }
    public void gerarRelatorio(...) { }
}
```

### O - Open/Closed

```java
// âœ… CORRETO - ExtensÃ­vel via interface
public interface ValidadorPedido {
    void validar(Pedido pedido);
}

@Component
public class ValidadorItensObrigatorios implements ValidadorPedido {
    public void validar(Pedido pedido) {
        if (pedido.getItens().isEmpty()) {
            throw new ValidacaoException("Pedido deve ter itens");
        }
    }
}

@Component
public class ValidadorValorMinimo implements ValidadorPedido {
    public void validar(Pedido pedido) {
        if (pedido.calcularTotal().compareTo(new BigDecimal("10")) < 0) {
            throw new ValidacaoException("Valor mÃ­nimo Ã© R$ 10,00");
        }
    }
}

// Adicionar novos validadores sem modificar existentes
@Component
public class ValidadorHorarioFuncionamento implements ValidadorPedido {
    public void validar(Pedido pedido) { ... }
}
```

### L - Liskov Substitution

```java
// âœ… CORRETO - Subtipos sÃ£o substituÃ­veis
public abstract class Pagamento {
    protected BigDecimal valor;
    protected StatusPagamento status;
    
    public abstract void processar();
    public abstract void estornar();
    
    public BigDecimal getValor() { return valor; }
    public StatusPagamento getStatus() { return status; }
}

public class PagamentoCartao extends Pagamento {
    private final String numeroCartao;
    
    @Override
    public void processar() {
        // Processa cartÃ£o
        this.status = StatusPagamento.APROVADO;
    }
    
    @Override
    public void estornar() {
        // Estorna cartÃ£o
        this.status = StatusPagamento.ESTORNADO;
    }
}

public class PagamentoPix extends Pagamento {
    private final String chavePix;
    
    @Override
    public void processar() { ... }
    
    @Override
    public void estornar() { ... }
}
```

### I - Interface Segregation

```java
// âœ… CORRETO - Interfaces pequenas e focadas
public interface PedidoRepositoryPort {
    Pedido salvar(Pedido pedido);
    Optional<Pedido> buscarPorId(String id);
    List<Pedido> buscarPorCliente(String clienteId);
}

public interface PedidoRelatorioPort {
    List<Pedido> buscarPorPeriodo(LocalDate inicio, LocalDate fim);
    BigDecimal calcularTotalPeriodo(LocalDate inicio, LocalDate fim);
}

public interface PedidoNotificacaoPort {
    void notificarCriacao(Pedido pedido);
    void notificarAtualizacao(Pedido pedido);
}

// âŒ ERRADO - Interface muito grande
public interface PedidoPort {
    Pedido salvar(Pedido pedido);
    Optional<Pedido> buscarPorId(String id);
    List<Pedido> buscarTodos();
    List<Pedido> buscarPorCliente(String clienteId);
    List<Pedido> buscarPorPeriodo(LocalDate inicio, LocalDate fim);
    void excluir(String id);
    void notificar(Pedido pedido);
    void enviarEmail(Pedido pedido);
    BigDecimal calcularTotal(String id);
    void gerarRelatorio(LocalDate data);
}
```

### D - Dependency Inversion

```java
// âœ… CORRETO - Depende de abstraÃ§Ãµes (Port interfaces)
@Service
@RequiredArgsConstructor
public class CriarPedidoUseCase {
    // Depende de interfaces (ports), nÃ£o de implementaÃ§Ãµes
    private final PedidoRepositoryPort repository;  // Interface
    private final ClienteRepositoryPort clienteRepository;  // Interface
    private final NotificacaoPort notificacao;  // Interface
    
    public PedidoDTO executar(CriarPedidoRequest request) {
        Cliente cliente = clienteRepository.buscarPorId(request.clienteId())
            .orElseThrow(() -> new ClienteNaoEncontradoException(request.clienteId()));
            
        Pedido pedido = Pedido.criar(request.itens());
        Pedido salvo = repository.salvar(pedido);
        
        notificacao.notificarNovoPedido(salvo);
        
        return PedidoDTO.from(salvo);
    }
}

// âŒ ERRADO - Depende de implementaÃ§Ã£o concreta
@Service
public class CriarPedidoUseCase {
    private final PedidoJpaRepository repository;  // ImplementaÃ§Ã£o concreta
    private final EmailService emailService;  // ImplementaÃ§Ã£o concreta
}
```

---

## 5. ESTRUTURA DE PACOTES

### 5.1 Estrutura por MÃ³dulo

```
com.snackbar.{modulo}/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ Pedido.java
â”‚   â”œâ”€â”€ valueobjects/
â”‚   â”‚   â”œâ”€â”€ Preco.java
â”‚   â”‚   â””â”€â”€ StatusPedido.java
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ CalculadoraDescontoService.java
â”‚   â””â”€â”€ exceptions/
â”‚       â”œâ”€â”€ PedidoNaoEncontradoException.java
â”‚       â””â”€â”€ EstadoInvalidoException.java
â”‚
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ usecases/
â”‚   â”‚   â”œâ”€â”€ CriarPedidoUseCase.java
â”‚   â”‚   â”œâ”€â”€ BuscarPedidoUseCase.java
â”‚   â”‚   â””â”€â”€ CancelarPedidoUseCase.java
â”‚   â”œâ”€â”€ dtos/
â”‚   â”‚   â”œâ”€â”€ PedidoDTO.java
â”‚   â”‚   â”œâ”€â”€ CriarPedidoRequest.java
â”‚   â”‚   â””â”€â”€ AtualizarPedidoRequest.java
â”‚   â””â”€â”€ ports/
â”‚       â”œâ”€â”€ in/
â”‚       â”‚   â””â”€â”€ PedidoUseCasePort.java
â”‚       â””â”€â”€ out/
â”‚           â”œâ”€â”€ PedidoRepositoryPort.java
â”‚           â””â”€â”€ NotificacaoPort.java
â”‚
â””â”€â”€ infrastructure/
    â”œâ”€â”€ persistence/
    â”‚   â”œâ”€â”€ entities/
    â”‚   â”‚   â””â”€â”€ PedidoEntity.java
    â”‚   â”œâ”€â”€ repositories/
    â”‚   â”‚   â”œâ”€â”€ PedidoJpaRepository.java
    â”‚   â”‚   â””â”€â”€ PedidoRepositoryAdapter.java
    â”‚   â””â”€â”€ mappers/
    â”‚       â””â”€â”€ PedidoMapper.java
    â”œâ”€â”€ web/
    â”‚   â”œâ”€â”€ controllers/
    â”‚   â”‚   â””â”€â”€ PedidoController.java
    â”‚   â””â”€â”€ handlers/
    â”‚       â””â”€â”€ GlobalExceptionHandler.java
    â”œâ”€â”€ services/
    â”‚   â””â”€â”€ NotificacaoAdapter.java
    â””â”€â”€ config/
        â””â”€â”€ PedidoConfig.java
```

### 5.2 Kernel Compartilhado

```
com.snackbar.kernel/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ valueobjects/
â”‚   â”‚   â””â”€â”€ Dinheiro.java
â”‚   â””â”€â”€ exceptions/
â”‚       â””â”€â”€ DominioException.java
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ dtos/
â”‚   â”‚   â””â”€â”€ PaginacaoDTO.java
â”‚   â””â”€â”€ ports/
â”‚       â””â”€â”€ UseCase.java
â””â”€â”€ infrastructure/
    â”œâ”€â”€ mappers/
    â”‚   â”œâ”€â”€ MapperUtils.java
    â”‚   â””â”€â”€ MapperRegistry.java
    â””â”€â”€ config/
        â””â”€â”€ CommonConfig.java
```

---

## 6. CAMADA DOMAIN

### 6.1 Regras da Camada

âœ… **PODE TER:**
- Entidades e Aggregates
- Value Objects
- Domain Services
- ExceÃ§Ãµes de domÃ­nio
- Interfaces/Ports (quando necessÃ¡rio)
- Enums de domÃ­nio
- Eventos de domÃ­nio

âŒ **NÃƒO PODE TER:**
- AnotaÃ§Ãµes Spring (`@Service`, `@Component`, etc.)
- DependÃªncias de frameworks
- AnotaÃ§Ãµes JPA
- Imports de `org.springframework.*`
- Imports de `jakarta.persistence.*`

### 6.2 Exemplos PrÃ¡ticos

```java
// âœ… CORRETO - Entidade de domÃ­nio pura
package com.snackbar.pedidos.domain.entities;

import com.snackbar.pedidos.domain.valueobjects.Preco;
import com.snackbar.pedidos.domain.valueobjects.StatusPedido;
import com.snackbar.pedidos.domain.exceptions.EstadoInvalidoException;

public class Pedido {
    private final String id;
    private StatusPedido status;
    private final Preco total;
    
    // LÃ³gica de domÃ­nio...
}

// âŒ ERRADO - DomÃ­nio poluÃ­do com framework
package com.snackbar.pedidos.domain.entities;

import jakarta.persistence.*;  // âŒ JPA no domÃ­nio
import org.springframework.stereotype.Component;  // âŒ Spring no domÃ­nio

@Entity
@Table(name = "pedidos")
public class Pedido {
    @Id
    private String id;
    
    @Enumerated(EnumType.STRING)
    private StatusPedido status;
}
```

---

## 7. CAMADA APPLICATION

### 7.1 Use Cases

```java
@Service
@RequiredArgsConstructor
public class CriarPedidoUseCase {
    private final PedidoRepositoryPort pedidoRepository;
    private final ProdutoRepositoryPort produtoRepository;
    private final ValidadorPedidoService validador;
    private final MapperUtils mapper = MapperUtils.getInstance();
    
    @Transactional
    public PedidoDTO executar(CriarPedidoRequest request) {
        // 1. Validar request
        validarRequest(request);
        
        // 2. Buscar dependÃªncias
        List<Produto> produtos = buscarProdutos(request.itensIds());
        
        // 3. Criar entidade de domÃ­nio
        Pedido pedido = criarPedido(request, produtos);
        
        // 4. Validar regras de negÃ³cio
        validador.validar(pedido);
        
        // 5. Persistir
        Pedido salvo = pedidoRepository.salvar(pedido);
        
        // 6. Retornar DTO
        return PedidoDTO.from(salvo);
    }
    
    private void validarRequest(CriarPedidoRequest request) {
        if (request.clienteId() == null || request.clienteId().isBlank()) {
            throw new ValidacaoException("Cliente Ã© obrigatÃ³rio");
        }
        if (request.itensIds() == null || request.itensIds().isEmpty()) {
            throw new ValidacaoException("Pedido deve ter itens");
        }
    }
    
    private List<Produto> buscarProdutos(List<String> ids) {
        return ids.stream()
            .map(id -> produtoRepository.buscarPorId(id)
                .orElseThrow(() -> new ProdutoNaoEncontradoException(id)))
            .toList();
    }
    
    private Pedido criarPedido(CriarPedidoRequest request, List<Produto> produtos) {
        List<ItemPedido> itens = produtos.stream()
            .map(p -> ItemPedido.criar(p, 1))
            .toList();
        return Pedido.criar(request.clienteId(), itens);
    }
}
```

### 7.2 DTOs

```java
// âœ… CORRETO - DTO como record com factory method
public record PedidoDTO(
    String id,
    String clienteId,
    List<ItemPedidoDTO> itens,
    String status,
    BigDecimal total,
    Instant criadoEm
) {
    public static PedidoDTO from(Pedido pedido) {
        return new PedidoDTO(
            pedido.getId(),
            pedido.getClienteId(),
            pedido.getItens().stream()
                .map(ItemPedidoDTO::from)
                .toList(),
            pedido.getStatus().name(),
            pedido.calcularTotal(),
            pedido.getCriadoEm()
        );
    }
}

// âœ… CORRETO - Request DTO com validaÃ§Ãµes
public record CriarPedidoRequest(
    @NotBlank(message = "Cliente Ã© obrigatÃ³rio")
    String clienteId,
    
    @NotEmpty(message = "Pedido deve ter itens")
    List<@Valid ItemPedidoRequest> itens,
    
    String observacao
) { }
```

### 7.3 Ports (Interfaces)

```java
// Port de saÃ­da (o que o Use Case precisa)
package com.snackbar.pedidos.application.ports.out;

public interface PedidoRepositoryPort {
    Pedido salvar(Pedido pedido);
    Optional<Pedido> buscarPorId(String id);
    List<Pedido> buscarPorCliente(String clienteId);
    List<Pedido> buscarPorStatus(StatusPedido status);
    void excluir(String id);
}

// Port de entrada (o que expÃµe para fora)
package com.snackbar.pedidos.application.ports.in;

public interface CriarPedidoUseCasePort {
    PedidoDTO executar(CriarPedidoRequest request);
}
```

---

## 8. CAMADA INFRASTRUCTURE

### 8.1 Entities JPA

```java
@Entity
@Table(name = "pedidos")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)  // Para JPA
@AllArgsConstructor(access = AccessLevel.PRIVATE)   // Para Builder
@Builder
public class PedidoEntity {
    
    @Id
    private String id;
    
    @Column(name = "cliente_id", nullable = false)
    private String clienteId;
    
    @OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<ItemPedidoEntity> itens = new ArrayList<>();
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusPedido status;
    
    @Column(precision = 10, scale = 2)
    private BigDecimal total;
    
    @Column(name = "criado_em", nullable = false)
    private Instant criadoEm;
    
    @Column(name = "atualizado_em")
    private Instant atualizadoEm;
    
    @PrePersist
    void prePersist() {
        this.criadoEm = Instant.now();
    }
    
    @PreUpdate
    void preUpdate() {
        this.atualizadoEm = Instant.now();
    }
}
```

### 8.2 Repository Adapter

```java
@Component
@RequiredArgsConstructor
public class PedidoRepositoryAdapter implements PedidoRepositoryPort {
    
    private final PedidoJpaRepository jpaRepository;
    private final PedidoMapper mapper;
    
    @Override
    public Pedido salvar(Pedido pedido) {
        PedidoEntity entity = mapper.toEntity(pedido);
        PedidoEntity salvo = jpaRepository.save(entity);
        return mapper.toDomain(salvo);
    }
    
    @Override
    public Optional<Pedido> buscarPorId(String id) {
        return jpaRepository.findById(id)
            .map(mapper::toDomain);
    }
    
    @Override
    public List<Pedido> buscarPorCliente(String clienteId) {
        return jpaRepository.findByClienteId(clienteId).stream()
            .map(mapper::toDomain)
            .toList();
    }
    
    @Override
    public List<Pedido> buscarPorStatus(StatusPedido status) {
        return jpaRepository.findByStatus(status).stream()
            .map(mapper::toDomain)
            .toList();
    }
    
    @Override
    public void excluir(String id) {
        jpaRepository.deleteById(id);
    }
}
```

### 8.3 Controllers

```java
@RestController
@RequestMapping("/api/pedidos")
@RequiredArgsConstructor
public class PedidoController {
    
    private final CriarPedidoUseCase criarPedidoUseCase;
    private final BuscarPedidoUseCase buscarPedidoUseCase;
    private final ListarPedidosUseCase listarPedidosUseCase;
    private final CancelarPedidoUseCase cancelarPedidoUseCase;
    
    @PostMapping
    public ResponseEntity<PedidoDTO> criar(@Valid @RequestBody CriarPedidoRequest request) {
        PedidoDTO pedido = criarPedidoUseCase.executar(request);
        URI location = URI.create("/api/pedidos/" + pedido.id());
        return ResponseEntity.created(location).body(pedido);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<PedidoDTO> buscarPorId(@PathVariable String id) {
        return buscarPedidoUseCase.executar(id)
            .map(ResponseEntity::ok)
            .orElseThrow(() -> new PedidoNaoEncontradoException(id));
    }
    
    @GetMapping
    public ResponseEntity<List<PedidoDTO>> listar(
            @RequestParam(required = false) String clienteId,
            @RequestParam(required = false) String status) {
        var filtro = new FiltroPedido(clienteId, status);
        return ResponseEntity.ok(listarPedidosUseCase.executar(filtro));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> cancelar(@PathVariable String id) {
        cancelarPedidoUseCase.executar(id);
        return ResponseEntity.noContent().build();
    }
}
```

---

## 9. LOMBOK E JAVA 17

### 9.1 Lombok ObrigatÃ³rio

```java
// âœ… CORRETO - Sempre usar @RequiredArgsConstructor
@Service
@RequiredArgsConstructor
public class MeuUseCase {
    private final RepositoryPort repository;  // final = injetado
    private final OutroService servico;       // final = injetado
    private final MapperUtils mapper = MapperUtils.getInstance();  // nÃ£o-final = nÃ£o injetado
}

// âœ… CORRETO - Entities JPA com Lombok
@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Builder
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class ProdutoEntity { }

// âŒ PROIBIDO - Construtor manual
@Service
public class MeuUseCase {
    private final RepositoryPort repository;
    
    public MeuUseCase(RepositoryPort repository) {  // âŒ NUNCA
        this.repository = repository;
    }
}
```

### 9.2 Records do Java 17

```java
// âœ… CORRETO - Records para DTOs imutÃ¡veis
public record ProdutoDTO(
    String id,
    String nome,
    BigDecimal preco,
    String categoria
) {
    // Compact constructor para validaÃ§Ã£o
    public ProdutoDTO {
        Objects.requireNonNull(id, "ID nÃ£o pode ser nulo");
        Objects.requireNonNull(nome, "Nome nÃ£o pode ser nulo");
    }
    
    // Factory method
    public static ProdutoDTO from(Produto produto) {
        return new ProdutoDTO(
            produto.getId(),
            produto.getNome(),
            produto.getPreco().valor(),
            produto.getCategoria().nome()
        );
    }
}
```

### 9.3 Outras Features do Java 17

```java
// Pattern Matching com instanceof
if (objeto instanceof Produto produto) {
    System.out.println(produto.getNome());
}

// Switch Expression
String descricao = switch (status) {
    case PENDENTE -> "Aguardando";
    case EM_PREPARO -> "Preparando";
    case PRONTO -> "Pronto para retirada";
    case ENTREGUE -> "Finalizado";
};

// Text Blocks
String query = """
    SELECT p.id, p.nome, p.preco
    FROM produtos p
    WHERE p.categoria = :categoria
    ORDER BY p.nome
    """;

// Streams com toList()
List<String> nomes = produtos.stream()
    .map(Produto::getNome)
    .toList();  // âœ… Java 16+ (nÃ£o Collectors.toList())
```

---

## 10. MAPPERS E CONVERSÃ•ES

### 10.1 MapperUtils Singleton

```java
// âœ… CORRETO - Sempre singleton
private final MapperUtils mapper = MapperUtils.getInstance();

// âŒ PROIBIDO - Nova instÃ¢ncia
private final MapperUtils mapper = new MapperUtils();  // âŒ NUNCA
```

### 10.2 Mapper EspecÃ­fico de DomÃ­nio

```java
@Component
public class PedidoMapper {
    
    public PedidoEntity toEntity(Pedido pedido) {
        return PedidoEntity.builder()
            .id(pedido.getId())
            .clienteId(pedido.getClienteId())
            .status(pedido.getStatus())
            .total(pedido.calcularTotal())
            .criadoEm(pedido.getCriadoEm())
            .itens(pedido.getItens().stream()
                .map(this::toItemEntity)
                .toList())
            .build();
    }
    
    public Pedido toDomain(PedidoEntity entity) {
        List<ItemPedido> itens = entity.getItens().stream()
            .map(this::toItemDomain)
            .toList();
            
        return Pedido.reconstituir(
            entity.getId(),
            entity.getClienteId(),
            itens,
            entity.getStatus(),
            entity.getCriadoEm()
        );
    }
    
    private ItemPedidoEntity toItemEntity(ItemPedido item) {
        return ItemPedidoEntity.builder()
            .id(item.getId())
            .produtoId(item.getProdutoId())
            .quantidade(item.getQuantidade())
            .precoUnitario(item.getPrecoUnitario().valor())
            .build();
    }
    
    private ItemPedido toItemDomain(ItemPedidoEntity entity) {
        return ItemPedido.reconstituir(
            entity.getId(),
            entity.getProdutoId(),
            entity.getQuantidade(),
            Preco.of(entity.getPrecoUnitario())
        );
    }
}
```

### 10.3 Verificar Antes de Criar

```java
// âœ… SEMPRE verifique se jÃ¡ existe no kernel-compartilhado:
// - MapperUtils.getInstance()
// - MapperRegistry.getInstance()

// âœ… SEMPRE verifique se jÃ¡ existe mapper similar no mÃ³dulo

// âŒ NUNCA crie mapper duplicado
```

---

## 11. PERSISTÃŠNCIA E REPOSITÃ“RIOS

### 11.1 JPA Repository Interface

```java
public interface PedidoJpaRepository extends JpaRepository<PedidoEntity, String> {
    
    List<PedidoEntity> findByClienteId(String clienteId);
    
    List<PedidoEntity> findByStatus(StatusPedido status);
    
    @Query("SELECT p FROM PedidoEntity p WHERE p.criadoEm BETWEEN :inicio AND :fim")
    List<PedidoEntity> findByPeriodo(
        @Param("inicio") Instant inicio,
        @Param("fim") Instant fim
    );
    
    @Query("SELECT SUM(p.total) FROM PedidoEntity p WHERE p.status = :status")
    Optional<BigDecimal> calcularTotalPorStatus(@Param("status") StatusPedido status);
}
```

### 11.2 Queries Complexas

```java
@Repository
@RequiredArgsConstructor
public class PedidoQueryRepository {
    
    private final EntityManager entityManager;
    
    public List<PedidoResumoDTO> buscarResumoPorPeriodo(LocalDate inicio, LocalDate fim) {
        String jpql = """
            SELECT new com.snackbar.pedidos.application.dtos.PedidoResumoDTO(
                p.id,
                p.clienteId,
                p.status,
                p.total,
                p.criadoEm
            )
            FROM PedidoEntity p
            WHERE p.criadoEm BETWEEN :inicio AND :fim
            ORDER BY p.criadoEm DESC
            """;
            
        return entityManager.createQuery(jpql, PedidoResumoDTO.class)
            .setParameter("inicio", inicio.atStartOfDay().toInstant(ZoneOffset.UTC))
            .setParameter("fim", fim.plusDays(1).atStartOfDay().toInstant(ZoneOffset.UTC))
            .getResultList();
    }
}
```

---

## 12. VALIDAÃ‡Ã•ES E EXCEÃ‡Ã•ES

### 12.1 Hierarquia de ExceÃ§Ãµes

```java
// ExceÃ§Ã£o base do domÃ­nio
public abstract class DominioException extends RuntimeException {
    protected DominioException(String mensagem) {
        super(mensagem);
    }
}

// ExceÃ§Ãµes especÃ­ficas
public class EntidadeNaoEncontradaException extends DominioException {
    public EntidadeNaoEncontradaException(String entidade, String id) {
        super(String.format("%s nÃ£o encontrado(a): %s", entidade, id));
    }
}

public class PedidoNaoEncontradoException extends EntidadeNaoEncontradaException {
    public PedidoNaoEncontradoException(String id) {
        super("Pedido", id);
    }
}

public class RegraDeNegocioException extends DominioException {
    public RegraDeNegocioException(String mensagem) {
        super(mensagem);
    }
}

public class EstadoInvalidoException extends RegraDeNegocioException {
    public EstadoInvalidoException(String mensagem) {
        super(mensagem);
    }
}
```

### 12.2 Exception Handler Global

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(EntidadeNaoEncontradaException.class)
    public ResponseEntity<ErroResponse> handleEntidadeNaoEncontrada(EntidadeNaoEncontradaException ex) {
        log.warn("Entidade nÃ£o encontrada: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(new ErroResponse(ex.getMessage(), "NOT_FOUND"));
    }
    
    @ExceptionHandler(RegraDeNegocioException.class)
    public ResponseEntity<ErroResponse> handleRegraDeNegocio(RegraDeNegocioException ex) {
        log.warn("Regra de negÃ³cio violada: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY)
            .body(new ErroResponse(ex.getMessage(), "BUSINESS_RULE_VIOLATION"));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErroValidacaoResponse> handleValidacao(MethodArgumentNotValidException ex) {
        List<CampoErro> erros = ex.getBindingResult().getFieldErrors().stream()
            .map(e -> new CampoErro(e.getField(), e.getDefaultMessage()))
            .toList();
        return ResponseEntity.badRequest()
            .body(new ErroValidacaoResponse("Dados invÃ¡lidos", erros));
    }
}

public record ErroResponse(String mensagem, String codigo) { }
public record CampoErro(String campo, String mensagem) { }
public record ErroValidacaoResponse(String mensagem, List<CampoErro> erros) { }
```

### 12.3 ValidaÃ§Ã£o em Use Cases

```java
@Service
@RequiredArgsConstructor
public class CriarPedidoUseCase {
    
    public PedidoDTO executar(CriarPedidoRequest request) {
        // ValidaÃ§Ã£o de entrada
        validarRequest(request);
        
        // ValidaÃ§Ã£o de regras de negÃ³cio
        validarRegrasNegocio(request);
        
        // ... resto da lÃ³gica
    }
    
    private void validarRequest(CriarPedidoRequest request) {
        List<String> erros = new ArrayList<>();
        
        if (request.clienteId() == null || request.clienteId().isBlank()) {
            erros.add("Cliente Ã© obrigatÃ³rio");
        }
        if (request.itens() == null || request.itens().isEmpty()) {
            erros.add("Pedido deve ter ao menos um item");
        }
        
        if (!erros.isEmpty()) {
            throw new ValidacaoException(String.join("; ", erros));
        }
    }
}
```

---

## 13. MIGRAÃ‡Ã•ES COM LIQUIBASE

### 13.1 Estrutura de Arquivos

```
src/main/resources/db/changelog/
â”œâ”€â”€ db.changelog-master.yml
â”œâ”€â”€ changes/
â”‚   â”œâ”€â”€ 20240101120000-criar-tabela-produtos.yml
â”‚   â”œâ”€â”€ 20240102100000-criar-tabela-pedidos.yml
â”‚   â””â”€â”€ 20240103090000-adicionar-coluna-observacao.yml
â””â”€â”€ data/
    â””â”€â”€ 20240101130000-dados-iniciais.yml
```

### 13.2 Changelog Master

```yaml
# db.changelog-master.yml
databaseChangeLog:
  - includeAll:
      path: db/changelog/changes/
      relativeToChangelogFile: false
```

### 13.3 Changeset Exemplo

```yaml
# 20240101120000-criar-tabela-produtos.yml
databaseChangeLog:
  - changeSet:
      id: 20240101120000-criar-tabela-produtos
      author: desenvolvedor
      changes:
        - createTable:
            tableName: produtos
            columns:
              - column:
                  name: id
                  type: VARCHAR(36)
                  constraints:
                    primaryKey: true
                    nullable: false
              - column:
                  name: nome
                  type: VARCHAR(100)
                  constraints:
                    nullable: false
              - column:
                  name: preco
                  type: DECIMAL(10, 2)
                  constraints:
                    nullable: false
              - column:
                  name: categoria_id
                  type: VARCHAR(36)
                  constraints:
                    nullable: false
                    foreignKeyName: fk_produto_categoria
                    references: categorias(id)
              - column:
                  name: criado_em
                  type: TIMESTAMP
                  defaultValueComputed: CURRENT_TIMESTAMP
                  constraints:
                    nullable: false
        
        - createIndex:
            tableName: produtos
            indexName: idx_produto_categoria
            columns:
              - column:
                  name: categoria_id
      
      rollback:
        - dropTable:
            tableName: produtos
```

### 13.4 Regras ObrigatÃ³rias

- âœ… **SEMPRE** inclua rollback
- âœ… **SEMPRE** use nomenclatura: `{YYYYMMDDHHmmss}-{descricao}.yml`
- âœ… **SEMPRE** crie Ã­ndices para campos de busca frequente
- âœ… **SEMPRE** use constraints apropriadas (NOT NULL, UNIQUE, FK)
- âŒ **NUNCA** altere changelogs jÃ¡ aplicados
- âŒ **NUNCA** use IDs sequenciais simples (1, 2, 3)

---

## 14. TESTES

### 14.1 Estrutura de Testes

```
src/test/java/com/snackbar/pedidos/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ PedidoTest.java
â”‚   â””â”€â”€ valueobjects/
â”‚       â””â”€â”€ PrecoTest.java
â”œâ”€â”€ application/
â”‚   â””â”€â”€ usecases/
â”‚       â”œâ”€â”€ CriarPedidoUseCaseTest.java
â”‚       â””â”€â”€ CancelarPedidoUseCaseTest.java
â””â”€â”€ infrastructure/
    â”œâ”€â”€ persistence/
    â”‚   â””â”€â”€ PedidoRepositoryAdapterTest.java
    â””â”€â”€ web/
        â””â”€â”€ PedidoControllerTest.java
```

### 14.2 Testes de DomÃ­nio

```java
class PedidoTest {
    
    @Test
    void deveCriarPedidoComStatusPendente() {
        // Arrange
        List<ItemPedido> itens = List.of(
            ItemPedido.criar(criarProduto(), 2)
        );
        
        // Act
        Pedido pedido = Pedido.criar("cliente-123", itens);
        
        // Assert
        assertThat(pedido.getStatus()).isEqualTo(StatusPedido.PENDENTE);
        assertThat(pedido.getItens()).hasSize(1);
    }
    
    @Test
    void deveLancarExcecaoAoCriarPedidoSemItens() {
        // Arrange & Act & Assert
        assertThatThrownBy(() -> Pedido.criar("cliente-123", List.of()))
            .isInstanceOf(RegraDeNegocioException.class)
            .hasMessageContaining("deve ter ao menos um item");
    }
    
    @Test
    void deveConfirmarPedidoPendente() {
        // Arrange
        Pedido pedido = criarPedidoPendente();
        
        // Act
        pedido.confirmar();
        
        // Assert
        assertThat(pedido.getStatus()).isEqualTo(StatusPedido.CONFIRMADO);
    }
    
    @Test
    void naoDeveConfirmarPedidoJaConfirmado() {
        // Arrange
        Pedido pedido = criarPedidoConfirmado();
        
        // Act & Assert
        assertThatThrownBy(pedido::confirmar)
            .isInstanceOf(EstadoInvalidoException.class);
    }
}
```

### 14.3 Testes de Use Case

```java
@ExtendWith(MockitoExtension.class)
class CriarPedidoUseCaseTest {
    
    @Mock
    private PedidoRepositoryPort pedidoRepository;
    
    @Mock
    private ProdutoRepositoryPort produtoRepository;
    
    @InjectMocks
    private CriarPedidoUseCase useCase;
    
    @Test
    void deveCriarPedidoComSucesso() {
        // Arrange
        CriarPedidoRequest request = new CriarPedidoRequest(
            "cliente-123",
            List.of(new ItemPedidoRequest("produto-1", 2))
        );
        
        Produto produto = criarProdutoMock();
        when(produtoRepository.buscarPorId("produto-1"))
            .thenReturn(Optional.of(produto));
        when(pedidoRepository.salvar(any()))
            .thenAnswer(inv -> inv.getArgument(0));
        
        // Act
        PedidoDTO resultado = useCase.executar(request);
        
        // Assert
        assertThat(resultado).isNotNull();
        assertThat(resultado.clienteId()).isEqualTo("cliente-123");
        verify(pedidoRepository).salvar(any(Pedido.class));
    }
    
    @Test
    void deveLancarExcecaoQuandoProdutoNaoExiste() {
        // Arrange
        CriarPedidoRequest request = new CriarPedidoRequest(
            "cliente-123",
            List.of(new ItemPedidoRequest("produto-inexistente", 1))
        );
        
        when(produtoRepository.buscarPorId("produto-inexistente"))
            .thenReturn(Optional.empty());
        
        // Act & Assert
        assertThatThrownBy(() -> useCase.executar(request))
            .isInstanceOf(ProdutoNaoEncontradoException.class);
    }
}
```

### 14.4 Testes de IntegraÃ§Ã£o

```java
@SpringBootTest
@AutoConfigureMockMvc
@Transactional
class PedidoControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Autowired
    private PedidoJpaRepository pedidoRepository;
    
    @Test
    void deveCriarPedidoViaApi() throws Exception {
        // Arrange
        CriarPedidoRequest request = new CriarPedidoRequest(
            "cliente-123",
            List.of(new ItemPedidoRequest("produto-1", 2))
        );
        
        // Act & Assert
        mockMvc.perform(post("/api/pedidos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").exists())
            .andExpect(jsonPath("$.status").value("PENDENTE"));
    }
    
    @Test
    void deveRetornar404QuandoPedidoNaoExiste() throws Exception {
        mockMvc.perform(get("/api/pedidos/id-inexistente"))
            .andExpect(status().isNotFound());
    }
}
```

---

## 15. ANTI-PATTERNS

### âŒ ProibiÃ§Ãµes Absolutas

1. **Entidades anÃªmicas** (apenas getters/setters, sem comportamento)
2. **DomÃ­nio com dependÃªncias de framework** (JPA, Spring no domain)
3. **Construtor manual quando Lombok resolve** (`@RequiredArgsConstructor`)
4. **`new MapperUtils()`** ao invÃ©s de `.getInstance()`
5. **God Classes** com mÃºltiplas responsabilidades
6. **Retornar `null`** quando pode usar `Optional`
7. **Catch vazio** ou genÃ©rico demais
8. **Queries SQL** diretamente no Controller
9. **LÃ³gica de negÃ³cio** no Controller
10. **Camadas invertidas** (Domain dependendo de Infrastructure)
11. **Use Cases fazendo muitas coisas** (dividir em casos menores)
12. **DTOs sem validaÃ§Ã£o** de entrada

### âš ï¸ Code Smells a Evitar

```java
// âŒ Service gigante fazendo tudo
@Service
public class PedidoService {
    // 500+ linhas
    // CRUD + validaÃ§Ã£o + cÃ¡lculos + notificaÃ§Ã£o + relatÃ³rios
}

// âŒ Entidade anÃªmica
public class Pedido {
    private String id;
    private StatusPedido status;
    
    // Apenas getters e setters
    public void setStatus(StatusPedido status) { this.status = status; }
}

// âŒ Regra de negÃ³cio no Controller
@PostMapping
public ResponseEntity<PedidoDTO> criar(@RequestBody CriarPedidoRequest request) {
    if (request.getValor() < 10) {  // âŒ Regra aqui
        throw new RuntimeException("Valor mÃ­nimo...");
    }
    // ...
}

// âŒ Domain com JPA
package com.snackbar.pedidos.domain.entities;
@Entity  // âŒ JPA no domÃ­nio
public class Pedido { }
```

---

## 16. CHECKLIST DE QUALIDADE

### Antes de Criar uma Classe

- [ ] Verificar se nÃ£o existe classe similar
- [ ] Definir em qual camada pertence (Domain/Application/Infrastructure)
- [ ] Planejar responsabilidade Ãºnica
- [ ] Definir se usarÃ¡ Lombok

### Antes de Commitar

- [ ] Clean Architecture respeitada (dependÃªncias corretas)
- [ ] Domain sem dependÃªncias de framework
- [ ] Usando `@RequiredArgsConstructor` (nÃ£o construtor manual)
- [ ] Usando `MapperUtils.getInstance()` (singleton)
- [ ] Use Cases pequenos e focados
- [ ] Entidades ricas (com comportamento)
- [ ] Value Objects imutÃ¡veis
- [ ] ExceÃ§Ãµes especÃ­ficas e tratadas
- [ ] Arquivos com menos de 300 linhas
- [ ] MÃ©todos com menos de 20 linhas
- [ ] Testes para lÃ³gica de negÃ³cio
- [ ] MigraÃ§Ãµes Liquibase com rollback

### RevisÃ£o de Arquitetura

- [ ] Interfaces (Ports) definidas na Application
- [ ] ImplementaÃ§Ãµes (Adapters) na Infrastructure
- [ ] DTOs na Application, nÃ£o no Domain
- [ ] ValidaÃ§Ãµes de entrada nos Use Cases
- [ ] Regras de negÃ³cio nas Entidades/Domain Services

---

## ğŸ“š RECURSOS DO PROJETO

### Kernel Compartilhado

```java
// Mappers
MapperUtils.getInstance()
MapperRegistry.getInstance()

// Value Objects comuns
Dinheiro.of(valor)

// ExceÃ§Ãµes base
DominioException
EntidadeNaoEncontradaException
```

### Estrutura de MÃ³dulos

```
â”œâ”€â”€ kernel-compartilhado/    # Classes compartilhadas
â”œâ”€â”€ autenticacao/            # MÃ³dulo de autenticaÃ§Ã£o
â”œâ”€â”€ gestao-cardapio/         # GestÃ£o de cardÃ¡pio
â”œâ”€â”€ gestao-clientes/         # GestÃ£o de clientes
â”œâ”€â”€ gestao-pedidos/          # GestÃ£o de pedidos
â”œâ”€â”€ impressao-cupom-fiscal/  # ImpressÃ£o fiscal
â””â”€â”€ sistema-orquestrador/    # OrquestraÃ§Ã£o de serviÃ§os
```

---

**ğŸš¨ LEMBRE-SE: CÃ³digo Java limpo Ã© tipado, imutÃ¡vel quando possÃ­vel, e segue Clean Architecture rigorosamente!**
